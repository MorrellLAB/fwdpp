<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: Tutorial</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="purpose"></a>
Purpose</h1>
<p>This document will guide you through writing custom policies affecting the biology of a population in the simulation.</p>
<h1><a class="anchor" id="model"></a>
The model</h1>
<p>We will model the evolution of a locus where mutation effects are drawn from a Gaussian distribution with mean 0 and standard deviation sigma_s.<br/>
 <br/>
 The effect of a haplotype is the sum of mutation effects on that gamete, and the phenotypic value of a diploid is P = min(sum1,sum2) + R, where the two sums are the effects of haplotypes 1 and 2 and R is another Gaussian with mean 0 and standard deviation sigma_e. The fitness of a diploid is then determined using a unit Gaussian with mean X. <br/>
 <br/>
 Mutations will occur uniformly along the interval [0,1) according to the infinitely-many sites model, and recombination is uniform on the same interval. <br/>
</p>
<h1><a class="anchor" id="mutmodel"></a>
Defining the mutation model</h1>
<p>There will be two mutation rates, u and us. The former is the mutation rate per gamete to neutral mutations. The latter is the mutation rate to selected mutations. Further, the position of a new mutation must not be the same as any currently-segregating mutation.<br/>
 <br/>
 We will make use of the existing mutation type <a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html" title="The simplest mutation type, adding just a selection coefficient and dominance to the interface...">KTfwd::mutation</a>, which has a selection coefficient, s, added to the base class <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html" title="Base class for mutations At minimum, a mutation must contain a position and a count in the population...">KTfwd::mutation_base</a>. For this model, haplotypes are the unit of evolution, so we can ignore the h (dominance) that is part of <a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html" title="The simplest mutation type, adding just a selection coefficient and dominance to the interface...">KTfwd::mutation</a>, and we'll just leave it at the default value of 0.5. <br/>
 We will use a lookup table of current mutation positions in order to make sure that we assign novel positions to new mutations. The most effective way to do that is to use a hash table. I recommend std::unordered_set. It is used as follows: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unordered_set&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> std::unordered_set&lt;double,std::hash&lt;double&gt;,<a class="code" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt; lookup_table_type;</div>
</div><!-- fragment --><p>In the above code block, we have replace the default std::operator== with <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html" title="Returns true if std::max(lhs,rhs)-std::min(lhs,rhs) &lt;= std::numeric_limits&lt;T&gt;::epsilon() ...">KTfwd::equal_eps</a>. This will result in two doubles being considered equal if the difference between them is &lt;= std::numeric_limits&lt;double&gt;::epsilon(), helping us skirt numeric precision issues inherent in the comparison of floating point values.<br/>
 <br/>
 Our mutation function will use the GNU Scientific Library for random number generation, and is implemented as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="../../d1/d7f/structKTfwd_1_1mutation.html">KTfwd::mutation</a> custom_mutation_model( gsl_rng * r, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; u, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; us,<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; sigma_s,lookup_table_type * lookup)</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">double</span> pos = gsl_rng_uniform(r);</div>
<div class="line"><span class="keywordflow">while</span>( lookup-&gt;find(pos) != lookup-&gt;end() )</div>
<div class="line">{</div>
<div class="line">pos = gsl_rng_uniform(r);</div>
<div class="line">}</div>
<div class="line">lookup-&gt;insert(pos); <span class="comment">//update the lookup table w/the accepted position</span></div>
<div class="line"><span class="keywordtype">double</span> s = 0.;</div>
<div class="line"><span class="comment">//ask if mutation is selected</span></div>
<div class="line"><span class="keywordflow">if</span>( gsl_rng_uniform(r) &lt;= us/(us+u) )</div>
<div class="line">{</div>
<div class="line">s = gsl_ran_gaussian(r,sigma_s);</div>
<div class="line">}</div>
<div class="line"><span class="comment">//return a new mutation at position pos with effect s and count of 1 in the population.</span></div>
<div class="line"><span class="comment">//Internally, the mutation constructor will check if s==0 or not set KTfwd::mutation::neutral to true or false as appropriate</span></div>
<div class="line"><span class="keywordflow">return</span> <a class="code" href="../../d1/d7f/structKTfwd_1_1mutation.html">KTfwd::mutation</a>(pos,s,1);</div>
<div class="line">}</div>
</div><!-- fragment --><p> In order to pass this mutation policy to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9566be0bd568e2e75b02b1f46457c25c">KTfwd::mutate</a>, we must construct a function call that <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9566be0bd568e2e75b02b1f46457c25c">KTfwd::mutate</a> may access. This is most easily accomplished via std::bind: </p>
<div class="fragment"><div class="line">std::bind( custom_mutation_model(r,u,us,sigma_s,&amp;lookup) );</div>
</div><!-- fragment --><p> <br/>
 As an aside, I typically pass a non-const pointer to the mutation list. This allows me to do some extra checking to make sure that the lookup table is doing its job. See diploid.cc for and example.</p>
<h1><a class="anchor" id="fitnessmodel"></a>
Defining the fitness model</h1>
<p>A fitness model will be passed iterators two gametes by one of the <a class="el" href="../../da/d8b/namespaceKTfwd.html#a946efaa4a6095f4f2aadda44a809a477">KTfwd::sample_diploid</a> functions. The programmer may define the fitness function to take other arguments and pass placeholders to the two gametes using std::bind. I typically defined fitness models as function objects rather than functions, which is convienient if they will be templates (because operator() can deduce template types during instantiation more readily than regular functions):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>custom_fitness_model</div>
<div class="line"><span class="comment">//Yes, this may be a weird fitness model.  Dominance of a haplotype depends on the value of X, etc.</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> result_type;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator&gt;</div>
<div class="line"><span class="keyword">inline</span> result_type operator()( <span class="keyword">const</span> iterator &amp; gamete1, <span class="keyword">const</span> iterator &amp; gamete2, gsl_rng * r, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; sigma_e, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; X )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">result_type sum1=0.,sum2=0;</div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i = 0 ; i &lt; gametes1.smutations.size() ; ++i )</div>
<div class="line">{</div>
<div class="line">sum1 += i-&gt;s;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i = 0 ; i &lt; gametes2.smutations.size() ; ++i )</div>
<div class="line">{</div>
<div class="line">sum2 += i-&gt;s;</div>
<div class="line">}</div>
<div class="line">result_type pheno = std::min(sum1,sum2) + gsl_ran_gaussian(r,sigma_e);</div>
<div class="line"><span class="comment">//fitness is Gaussian with mean X and std_dev = 1</span></div>
<div class="line">result_type fitness = std::exp( (-1.*std::pow( (X-pheno),2.))/2. );</div>
<div class="line"><span class="keywordflow">return</span> fitness;</div>
<div class="line">}</div>
<div class="line">};</div>
</div><!-- fragment --><p> To pass the fitness function to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a946efaa4a6095f4f2aadda44a809a477">KTfwd::sample_diploid</a>, use std::bind: </p>
<div class="fragment"><div class="line"><span class="comment">//_1 and _2 are placeholders for the iterators to gametes.  They will be passed in via sample_diploid.</span></div>
<div class="line">std::bind( custom_fitness_model(_1,_2,r,sigma_e,X) );</div>
</div><!-- fragment --><p>Please note that some C++ compilers may give errors with std::exp and std::pow even when &lt;cmath&gt; is included instead of &lt;math.h&gt;. In such cases, replace with exp and pow, respectively. Your mileage may vary. Not all compilers are on the same page with putting the C function in namespace std.</p>
<h1><a class="anchor" id="model2"></a>
Selection at sites linked to the sampled region.</h1>
<p>Here, we implement a mutation model for the recurrent hitch-hiking (RHH) model. In this model, beneficial mutations enter the population at a constant rate. These beneficial mutations have a constant selection coefficient and are codominant with respect to fitness. We model the evolution of a region of size theta = 4Nu and rho=4Nr in which neutral and selected mutations occur. We allow selected mutations to arise at positions linked to the region up to a genetic distance of s/rbp genetic units away (where rbp here is the recombination rate per base pair), following the classic theory. <br/>
 <br/>
 The relevant parameters of this model are: Lambda = the number of fixations of beneficial mutations per 4N generations per region of site theta r = the recombination rate per diploid per generation per site L = the length of the sampled region in base pairs. s = the selection coefficient <br/>
 <br/>
 From the above parameters, and from classical population genetic theory, the mutation rate (per gamete, per site) to mutations with selection coefficient s is:<br/>
</p>
<div class="fragment"><div class="line"><span class="comment">//use the result on fixation probability for codominant mutation with selection coefficient s to work backwards to mutation rate per size</span></div>
<div class="line"><span class="keywordtype">double</span> mu_pos_bp = (lambda &gt; 0.) ? ((lambda*(1-exp(-4.*<span class="keywordtype">double</span>(N0)*s)))/(8.*pow(<span class="keywordtype">double</span>(N0),2.)*(1.-exp(-2.*s))))/<span class="keywordtype">double</span>(nsites) : 0.;</div>
</div><!-- fragment --><p>From theory, the maximum genetic distance at which a selected site will generate a hitch-hiking effect is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> maxd = 4*N*s;</div>
</div><!-- fragment --><p>We will use maxd in the following way: neutral mutations occur with position on the interval [0,1). Selected sites will occur with positions uniformly-distributed between -maxd and 1+maxd, to allow them to occur both within the neutral region and up to a distance maxd on eiter side. Further, the position of recombination events will be uniform on the interval [-maxd,1+maxd).</p>
<p>The recombination rates are: </p>
<div class="fragment"><div class="line"><span class="comment">//this is the recombination rate in the region of size theta</span></div>
<div class="line"><span class="keywordtype">double</span> littler_diploid_region = rho/double(4*N);</div>
<div class="line"><span class="comment">//this is the total recombination rate out to +/- maxd genetic units away from the region</span></div>
<div class="line"><span class="keywordtype">double</span> littler_diploid_ttl = littler_diploid_region + 2.*maxd/rho</div>
</div><!-- fragment --><p> We have the following other mutation rates: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mu_neutral = SOMETHING; <span class="comment">//defined somehow, applies only to neutral region of size theta</span></div>
<div class="line"><span class="comment">//selected mutation rate is selected mutation rate in region of size theta + selected mutation rate at flanking sites</span></div>
<div class="line"><span class="keywordtype">double</span> selected_mu_ttl =mu_pos_bp*double(L) + mu_pos_bp*2.*maxd/(littler/double(L-1))</div>
<div class="line"><span class="comment">//the probabilty that a selected mutation is within the sampled region is:</span></div>
<div class="line"><span class="keywordtype">double</span> pwithin = mu_pos_bp*<span class="keywordtype">double</span>(L)/selected_mu_ttl;</div>
</div><!-- fragment --><p>We may wish to keep track of when mutations arise in the population, so that we can track fixations times, etc.: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mutation_with_origin : <span class="keyword">public</span> <a class="code" href="../../d1/d7f/structKTfwd_1_1mutation.html">KTfwd::mutation</a></div>
<div class="line"><span class="comment">//records the generation when the mutation entered the population</span></div>
<div class="line">{</div>
<div class="line"><span class="comment">//o is the generation when the mutation arose (aka, the &quot;origination time&quot;)</span></div>
<div class="line"><span class="keyword">mutable</span> <span class="keywordtype">unsigned</span> o;</div>
<div class="line">mutation_with_origin (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp; __o ,<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; position, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; sel_coeff,<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp; count,</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp; dominance = 0.5) :</div>
<div class="line">o(__o),KTfwd::mutation(position,sel_coeff,count,dominance)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> mutation_with_origin mtype;</div>
</div><!-- fragment --><p> We can now write our mutation model: </p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> std::unordered_set&lt;double,std::hash&lt;double&gt;,<a class="code" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt; lookup_table_type;</div>
<div class="line">  mtype RHH_mutation_model( gsl_rng * r, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp; generation, <span class="keyword">const</span> <span class="keywordtype">double</span> mu_neutral, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; mu_selected,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; p_selected_within,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; s, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; h, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; maxd, lookup_table_type * lookup ) <span class="comment">//keep h (dominance) to 1 to match theory</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">//Will the mutation be neutral, or a selected one?</span></div>
<div class="line">  <span class="keywordtype">double</span> neutral = (gsl_rng_uniform(r) &lt;= mu_neutral/(mu_neutral+mu_selected)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordtype">double</span> pos = std::numeric_limits&lt;double&gt;::max(); <span class="comment">//set to some impossible dummy value</span></div>
<div class="line">  <span class="keywordtype">double</span> smut=0.;</div>
<div class="line">  <span class="keywordflow">if</span>( neutral )</div>
<div class="line">    {</div>
<div class="line">      pos = gsl_rng_uniform(r);</div>
<div class="line">      <span class="keywordflow">while</span>( lookup-&gt;find(pos) != lookup-&gt;end() )</div>
<div class="line">        {</div>
<div class="line">          pos = gsl_rng_uniform(r);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">bool</span> within = (gsl_rng_uniform(r) &lt;= p_selected_within) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line">      pos = (within) ? gsl_rng_uniform(r) : gsl_ran_flat(r,0.,maxd);</div>
<div class="line">      <span class="keywordflow">if</span>( ! within )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> (gsl_rng_uniform(r) &lt;= 0.5 )</div>
<div class="line">            {</div>
<div class="line">              pos *= -1.;</div>
<div class="line">            }</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">              pos += 1.;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">while</span>( lookup-&gt;find(pos) != lookup-&gt;end() )</div>
<div class="line">        {</div>
<div class="line">          pos = (within) ? gsl_rng_uniform(r) : gsl_ran_flat(r,0.,maxd);</div>
<div class="line">          <span class="keywordflow">if</span>( ! within )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> (gsl_rng_uniform(r) &lt;= 0.5)</div>
<div class="line">                {</div>
<div class="line">                  pos *= -1.;</div>
<div class="line">                }</div>
<div class="line">              <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                  pos += 1.;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      smut=s;</div>
<div class="line">    }</div>
<div class="line">  lookup-&gt;insert(pos);</div>
<div class="line">  <span class="keywordflow">return</span> mtype(generation,pos,smut,1,h);</div>
<div class="line">}</div>
</div><!-- fragment --><p>And we can pass that to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9566be0bd568e2e75b02b1f46457c25c">KTfwd::mutate</a> using std::bind: </p>
<div class="fragment"><div class="line">std::bind(RHH_mutation_model,r,mu_neutral,mu_selected_ttl,pwithin,s,h,maxd,&amp;lookup);</div>
</div><!-- fragment --><p>Note that the above mutation model specifies a region from position from -maxd to maxd+1. The interval from 0 to 1 is where neutral and selected mutations arise. The flanking bits out to +/- maxd or so are where selected mutations arise. Thus, we also need recombination on the interval from -maxd to maxd+1. We pass this function to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a41bccb4fd1108616d626e371c3cf83c4">KTfwd::recombine</a> as the genetic map: </p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> recurrent_sweep_genetic_map(gsl_rng * r, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; littler_neut,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; ttl_rec_rate,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; maxd)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> rdm = gsl_rng_uniform(r),pos;</div>
<div class="line">  <span class="keywordflow">if</span>( rdm &lt;= littler_neut/ttl_rec_rate )</div>
<div class="line">    {</div>
<div class="line">      pos = gsl_rng_uniform(r);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      pos = (gsl_rng_uniform(r) &lt;= 0.5) ? gsl_ran_flat(r,-1.*maxd,0.) : gsl_ran_flat(r,1.,1.+maxd);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> pos;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above is used as follows: </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> nrec = <a class="code" href="../../da/d8b/namespaceKTfwd.html#a41bccb4fd1108616d626e371c3cf83c4">KTfwd::recombine</a>(r, </div>
<div class="line">                                 &amp;gametes,</div>
<div class="line">                                 twoN, </div>
<div class="line">                                 littler,</div>
<div class="line">                                 <span class="comment">//genetic map uniform over total region, neutral + selected</span></div>
<div class="line">                                 std::bind( recurrent_sweep_genetic_map,r,littler_neut,</div>
<div class="line">                                              littler,maxd ) );</div>
</div><!-- fragment --><p> in order to get uniform recombination over the interval.</p>
<p>The appropriate fitness model would be struct <a class="el" href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html" title="Multiplicative fitness across sites. ">KTfwd::multiplicative_diploid</a> with a scaling of 2.0.</p>
<p>The fully-worked out code for this example is in RHH.cc, which also demonstrates how to print out fixation times, etc. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
