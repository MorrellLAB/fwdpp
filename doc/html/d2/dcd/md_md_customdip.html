<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: Advanced topics: custom diploid genotypes</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.4.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced topics: custom diploid genotypes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>I should read this before going apeshit: <a href="http://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures">http://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures</a></p>
<h2>Intro</h2>
<p>This section discusses how to implement simulations where a diploid's genotype is represented by a user-defined type.</p>
<p>This is a document covering advanced programming issues using <b>fwdpp</b>. Please see the introductory tutorials if you are new to programming with the library.</p>
<h2>Rationale</h2>
<p>In all versions of <b>fwdpp</b> <img class="formulaInl" alt="$\leq$" src="../../form_17.png"/> 0.3.0, the genotype of a diploid (at a single locus, including a specific locus in a multilocus simulation) had the following type:</p>
<div class="fragment"><div class="line"><span class="comment">//Note: standard_diploid_t is not, nor ever was, a fwdpp type--this is simply a typedef for illustration&#39;s sake.</span></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dea/namespaceKTfwd_1_1tags.html#a92fb7b7465637fb0a6b8cd9301b793f9">standard_diploid_t</a> = std::pair&lt; glist::iterator, glist::iterator&gt;;</div>
</div><!-- fragment --><p>And a single population was implemented as:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> standard_diploid_vec_t = std::vector&lt; standard_diploid_t &gt;;</div>
</div><!-- fragment --><p>Further, all fitness functions in the library (see <a class="el" href="../../d0/ddb/structKTfwd_1_1site__dependent__fitness.html" title="Function object for fitness as a function of individual mutations in a diploid. ">KTfwd::site_dependent_fitness</a>, for example) had the following form, and custom fitness models had to mimic this form as well (see <a class="el" href="../../d1/d7a/md_md_policies.html">Tutorial 1: Policies in fwdpp</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>fitness_model {</div>
<div class="line">        <span class="keyword">using</span> result_type = double;</div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_t&gt;</div>
<div class="line">        <span class="keyword">inline</span> operator()( <span class="keyword">const</span> iterator_t &amp; g1, <span class="keyword">const</span> iterator_t &amp; g2 )<span class="keyword"> const </span>{</div>
<div class="line">                <span class="comment">//Do something useful and return a result_type</span></div>
<div class="line">        }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This design meant that all diploids were <em>unlabelled</em>, meaning that things like separate sexes, geographic locations, etc., could not be modeled without writing explicit overloads of <a class="el" href="../../da/d8b/namespaceKTfwd.html#a18df6351fa3148914bbb844c36bc3e05">KTfwd::sample_diploid</a>. However, it <em>should</em> be possible to implement some forms of these more complex simulations without having to overload the sampling functions. Further, the library's template-based design should allow for these complexities to be dealt with at <em>compile-time</em> instead of at run time.</p>
<p>In <b>fwdpp</b> 0.3.1, I introduced the ability to specify diploid genotype types other than pairs of iterators to gametes. The library maintains source code compatibility with existing simulations via a tag/dispatch model. Basically, custom diploid genotype types are "tagged" at compile time.</p>
<h2>The minimal custom diploid type</h2>
<p>Your custom diploid type is constrained in the following ways:</p>
<ul>
<li>Its gamete iterator variables must be called "first" and "second".</li>
<li>The typedef first_type must exist, and be an alias for the iterator type.</li>
</ul>
<p>These requirements are minimal, and force your custom type to have the same names/typedefs as the standard pair template.</p>
<p>Thus, the minimal valid custom diploid type (at least as far as GCC and clang++ are concerned) is:</p>
<div class="fragment"><div class="line"><span class="comment">//Your type must inherit from public KTfwd::tags::custom_diploid_t</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> : <span class="keyword">public</span> <a class="code" href="../../df/d75/structKTfwd_1_1tags_1_1diploid__type.html">KTfwd::tags::custom_diploid_t</a></div>
<div class="line">{</div>
<div class="line">        <span class="keyword">using</span> <a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> = glist_t::iterator;</div>
<div class="line">        <span class="comment">//You don&#39;t need second_type here,</span></div>
<div class="line">        <span class="comment">//but I&#39;m including it for completeness vis-a-vis std::pair</span></div>
<div class="line">        <span class="keyword">using</span> <a class="code" href="../../dc/dfb/structdiploid__t.html#af6143429a41fdb4213375f181f25f0d7">second_type</a> = glist_t::iterator;</div>
<div class="line">        <span class="comment">//Iterator to gamete 1</span></div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> <a class="code" href="../../dc/dfb/structdiploid__t.html#a1d93eebfe52e4c4fcacace580b6837a2">first</a>;</div>
<div class="line">        <span class="comment">//Iterator to gamete 2</span></div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#af6143429a41fdb4213375f181f25f0d7">second_type</a> <a class="code" href="../../dc/dfb/structdiploid__t.html#ae41a7c599eed324dfe10ec1908fb4e41">second</a>;</div>
<div class="line">        <span class="comment">//Constructor</span></div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#a4c6a9115136d2d3741d2babbb1cfef6e">diploid_t</a>() : first(<a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a>()),<a class="code" href="../../dc/dfb/structdiploid__t.html#ae41a7c599eed324dfe10ec1908fb4e41">second</a>(<a class="code" href="../../dc/dfb/structdiploid__t.html#af6143429a41fdb4213375f181f25f0d7">second_type</a>()) {}</div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#a4c6a9115136d2d3741d2babbb1cfef6e">diploid_t</a>(<a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> g1, <a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> g2) : first(g1),<a class="code" href="../../dc/dfb/structdiploid__t.html#ae41a7c599eed324dfe10ec1908fb4e41">second</a>(g2){}</div>
<div class="line">};</div>
</div><!-- fragment --><p>The base class is the "dispatch tag" alluded to in the previous section. The "glist_t" is an alias for the doubly-linked list of gametes (see <a class="el" href="../../d5/d00/md_md_datatypes.html">Tutorial 0: Data types in fwdpp</a>).</p>
<h3>Separate sexes</h3>
<p>We are now able to add more data to our diploids:</p>
<div class="fragment"><div class="line"><span class="comment">//Your type must inherit from public KTfwd::tags::custom_diploid_t</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> : <span class="keyword">public</span> <a class="code" href="../../df/d75/structKTfwd_1_1tags_1_1diploid__type.html">KTfwd::tags::custom_diploid_t</a></div>
<div class="line">{</div>
<div class="line">        <span class="keyword">using</span> <a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> = glist_t::iterator;</div>
<div class="line">        <span class="comment">//You don&#39;t need second_type here,</span></div>
<div class="line">        <span class="comment">//but I&#39;m including it for completeness vis-a-vis std::pair</span></div>
<div class="line">        <span class="keyword">using</span> <a class="code" href="../../dc/dfb/structdiploid__t.html#af6143429a41fdb4213375f181f25f0d7">second_type</a> = glist_t::iterator;</div>
<div class="line">        <span class="comment">//Iterator to gamete 1</span></div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> <a class="code" href="../../dc/dfb/structdiploid__t.html#a1d93eebfe52e4c4fcacace580b6837a2">first</a>;</div>
<div class="line">        <span class="comment">//Iterator to gamete 2</span></div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#af6143429a41fdb4213375f181f25f0d7">second_type</a> <a class="code" href="../../dc/dfb/structdiploid__t.html#ae41a7c599eed324dfe10ec1908fb4e41">second</a>;</div>
<div class="line">        <span class="comment">//&quot;Sex&quot; of individual</span></div>
<div class="line">        <span class="keywordtype">bool</span> female;</div>
<div class="line">        <span class="comment">//Constructor -- and you may want to write others in this case...</span></div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#a4c6a9115136d2d3741d2babbb1cfef6e">diploid_t</a>() : first(<a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a>()),<a class="code" href="../../dc/dfb/structdiploid__t.html#ae41a7c599eed324dfe10ec1908fb4e41">second</a>(<a class="code" href="../../dc/dfb/structdiploid__t.html#af6143429a41fdb4213375f181f25f0d7">second_type</a>()),female(true) {}</div>
<div class="line">        <a class="code" href="../../dc/dfb/structdiploid__t.html#a4c6a9115136d2d3741d2babbb1cfef6e">diploid_t</a>(<a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> g1, <a class="code" href="../../dc/dfb/structdiploid__t.html#a3c41aff6f66667c8f51756799705efe5">first_type</a> g2) : first(g1),<a class="code" href="../../dc/dfb/structdiploid__t.html#ae41a7c599eed324dfe10ec1908fb4e41">second</a>(g2),female(true){}</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Fitness models</h2>
<p>We may now consider fitness policies that depend on the additional data in our custom diploid types. The fitness policies expecting two iterators to gametes are no longer sufficient, as they cannot know about the additional data in your custom type. Thus, a fitness policy that depends on a custom diploid type must take an iterator pointing to the diploid genotype type as an argument. In other words, a fitness policy must have the following form:</p>
<div class="fragment"><div class="line"><span class="comment">//Here, we assume diploid_t inherits from</span></div>
<div class="line"><span class="comment">// KTfwd::tags::custom_diploid_t</span></div>
<div class="line"><span class="keyword">using</span> diploid_vec_t = std::vector&lt; diploid_t &gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_new_fitness_pol {</div>
<div class="line">        <span class="keyword">using</span> result_type = double;</div>
<div class="line">        <span class="keyword">inline</span> result_type operator()( <span class="keyword">const</span> diploid_vec_t::const_iterator &amp; dip_itr )<span class="keyword"> const </span>{</div>
<div class="line">                <span class="comment">//Do something interesting and return a double.</span></div>
<div class="line">        }</div>
<div class="line">};</div>
</div><!-- fragment --><p>In other words, the <em>signature</em> of a fitness policy must be equivalent to:</p>
<div class="fragment"><div class="line">std::function&lt;double(const diploid_vec_t::const_iterator &amp;)&gt; my_new_fitness_pol = <span class="comment">//something</span></div>
</div><!-- fragment --><p>It is straightforward to implement such policies as templates, too. Let's look at a first pass at this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_new_fitness_pol_template {</div>
<div class="line">        <span class="keyword">using</span> result_type = double;</div>
<div class="line">        <span class="keyword">template</span>&lt; <span class="keyword">typename</span> diplo<span class="keywordtype">id</span>_genotype_itr &gt;</div>
<div class="line">        <span class="keyword">inline</span> result_type operator()( <span class="keyword">const</span> diploid_genotype_itr &amp; dip_itr )<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">//Do something interesting and return a double.</span></div>
<div class="line">        <span class="comment">//dip_itr-&gt;first will access the first gamete, etc.</span></div>
<div class="line">        }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The following built-in functions support custom diploids in this way:</p>
<ul>
<li><a class="el" href="../../d0/ddb/structKTfwd_1_1site__dependent__fitness.html" title="Function object for fitness as a function of individual mutations in a diploid. ">KTfwd::site_dependent_fitness</a></li>
<li><a class="el" href="../../d6/d39/structKTfwd_1_1additive__diploid.html" title="Additive fitness across sites. ">KTfwd::additive_diploid</a></li>
<li><a class="el" href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html" title="Multiplicative fitness across sites. ">KTfwd::multiplicative_diploid</a></li>
</ul>
<h3>Fitness models in multilocus simulations</h3>
<p>For multilocus simulations, a diploid is a vector of diploid genotype types, which by default is assumed to be a vector of pairs of iterators to gametes. Thus, for multilocus sims involving custom types, there is no need to make use of the dispatch tags discussed above, unless you want to use custom diploid types <em>and</em> the built-in fitness policies:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mloc_fitness {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> result_type;</div>
<div class="line">  <span class="keyword">inline</span> <span class="keywordtype">double</span> operator()( <span class="keyword">const</span> multiloc_t::dipvector_t::const_iterator &amp; diploid )<span class="keyword"> const </span>{</div>
<div class="line">     <span class="keyword">using</span> itr_t = multiloc_t::dipvector_t::const_iterator;</div>
<div class="line">     <span class="comment">//Fitness is additive across loci, and loci are additive over mutations:</span></div>
<div class="line">     <span class="keywordflow">return</span> std::accumulate( diploid.begin(), diploid.end(), 0, [](<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; w, <span class="keyword">const</span> itr_t::value_type &amp; __l ) {</div>
<div class="line">            <span class="keywordflow">return</span> w + <a class="code" href="../../d6/d39/structKTfwd_1_1additive__diploid.html">KTfwd::additive_diploid</a>(__l,2.);</div>
<div class="line">            } );</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Cost vs. benefit</h2>
<p>The pros of defining your own diploid type are:</p>
<ul>
<li>Being able to attach data to a diploid genotype beyond the two gametes that it contains. One can imagine all sorts of things here, but the existing code base may not (yet) support them all.</li>
</ul>
<p>The cons are:</p>
<ul>
<li>Fitness policies are written differently</li>
<li>In order to use the sugar layer's streamlined methods for declaring population containers, you must pass your diploid type to those templates (see <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a>).</li>
</ul>
<p>The cons mean that it is not trivial to switch an impementation back and forth between custom and non-custom diploid genotype representations. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
