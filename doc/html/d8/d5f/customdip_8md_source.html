<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>fwdpp: md/customdip.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">md/customdip.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d8/d5f/customdip_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Advanced topics: custom diploid genotypes</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;I should read this before going apeshit: http://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;## Intro</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;This section discusses how to implement simulations where a diploid&#39;s genotype is represented by a user-defined type.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;This is a document covering advanced programming issues using __fwdpp__.  Please see the introductory tutorials if you are new to programming with the library.</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;## Rationale</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;In all versions of __fwdpp__ \f$\leq\f$ 0.3.0, the genotype of a diploid (at a single locus, including a specific locus in a multilocus simulation) had the following type:</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;//Note: standard_diploid_t is not, nor ever was, a fwdpp type--this is simply a typedef for illustration&#39;s sake.</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;using standard_diploid_t = std::pair&lt; glist::iterator, glist::iterator&gt;;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;~~~</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;And a single population was implemented as:</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;using standard_diploid_vec_t = std::vector&lt; standard_diploid_t &gt;;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;~~~</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;Further, all fitness functions in the library (see KTfwd::site_dependent_fitness, for example) had the following form, and custom fitness models had to mimic this form as well (see @ref md_md_policies):</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;struct fitness_model {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   using result_type = double;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;   template&lt;typename iterator_t&gt;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   inline operator()( const iterator_t &amp; g1, const iterator_t &amp; g2 ) const {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;           //Do something useful and return a result_type</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;   }</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;};</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;~~~</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;This design meant that all diploids were _unlabelled_, meaning that things like separate sexes, geographic locations, etc., could not be modeled without writing explicit overloads of KTfwd::sample_diploid.  However, it _should_ be possible to implement some forms of these more complex simulations without having to overload the sampling functions.  Further, the library&#39;s template-based design should allow for these complexities to be dealt with at _compile-time_ instead of at run time.</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;In __fwdpp__ 0.3.1, I introduced the ability to specify diploid genotype types other than pairs of iterators to gametes.  The library maintains source code compatibility with existing simulations via a tag/dispatch model.  Basically, custom diploid genotype types are &quot;tagged&quot; at compile time.</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;## The minimal custom diploid type</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Your custom diploid type is constrained in the following ways:</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;* Its gamete iterator variables must be called &quot;first&quot; and &quot;second&quot;.</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;* The typedef first_type must exist, and be an alias for the iterator type.</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;These requirements are minimal, and force your custom type to have the same names/typedefs as the standard pair template.</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;Thus, the minimal valid custom diploid type (at least as far as GCC and clang++ are concerned) is:</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;//Your type must inherit from public KTfwd::tags::custom_diploid_t</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;struct diploid_t : public KTfwd::tags::custom_diploid_t</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;{</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;   using first_type = glist_t::iterator;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;   //You don&#39;t need second_type here,</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;   //but I&#39;m including it for completeness vis-a-vis std::pair</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;   using second_type = glist_t::iterator;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;   //Iterator to gamete 1</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;   first_type first;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   //Iterator to gamete 2</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   second_type second;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;   //Constructor</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;   diploid_t() : first(first_type()),second(second_type()) {}</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        diploid_t(first_type g1, first_type g2) : first(g1),second(g2){}</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;};</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;~~~</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;The base class is the &quot;dispatch tag&quot; alluded to in the previous section.  The &quot;glist_t&quot; is an alias for the doubly-linked list of gametes (see @ref md_md_datatypes).</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;### Separate sexes</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;We are now able to add more data to our diploids:</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;//Your type must inherit from public KTfwd::tags::custom_diploid_t</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;struct diploid_t : public KTfwd::tags::custom_diploid_t</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;   using first_type = glist_t::iterator;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;   //You don&#39;t need second_type here,</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;   //but I&#39;m including it for completeness vis-a-vis std::pair</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;   using second_type = glist_t::iterator;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;   //Iterator to gamete 1</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;   first_type first;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   //Iterator to gamete 2</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;   second_type second;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;   //&quot;Sex&quot; of individual</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   bool female;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;   //Constructor -- and you may want to write others in this case...</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;   diploid_t() : first(first_type()),second(second_type()),female(true) {}</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        diploid_t(first_type g1, first_type g2) : first(g1),second(g2),female(true){}</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;};</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;~~~</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;## Fitness models</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;We may now consider fitness policies that depend on the additional data in our custom diploid types.  The fitness policies expecting two iterators to gametes are no longer sufficient, as they cannot know about the additional data in your custom type.  Thus, a fitness policy that depends on a custom diploid type must take an iterator pointing to the diploid genotype type as an argument.  In other words, a fitness policy must have the following form:</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;//Here, we assume diploid_t inherits from</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;// KTfwd::tags::custom_diploid_t</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;using diploid_vec_t = std::vector&lt; diploid_t &gt;;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;struct my_new_fitness_pol {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   using result_type = double;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;   inline result_type operator()( const diploid_vec_t::const_iterator &amp; dip_itr ) const {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;           //Do something interesting and return a double.</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;   }</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;};</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;~~~</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;In other words, the _signature_ of a fitness policy must be equivalent to:</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;std::function&lt;double(const diploid_vec_t::const_iterator &amp;)&gt; my_new_fitness_pol = //something</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;~~~</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;It is straightforward to implement such policies as templates, too.  Let&#39;s look at a first pass at this:</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;struct my_new_fitness_pol_template {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;   using result_type = double;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;   template&lt; typename diploid_genotype_itr &gt;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;   inline result_type operator()( const diploid_genotype_itr &amp; dip_itr ) const {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   //Do something interesting and return a double.</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;   //dip_itr-&gt;first will access the first gamete, etc.</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;   }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;};</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;~~~</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;The following built-in functions support custom diploids in this way:</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;* KTfwd::site_dependent_fitness</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;* KTfwd::additive_diploid</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;* KTfwd::multiplicative_diploid</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;### Fitness models in multilocus simulations</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;For multilocus simulations, a diploid is a vector of diploid genotype types, which by default is assumed to be a vector of pairs of iterators to gametes.  Thus, for multilocus sims involving custom types, there is no need to make use of the dispatch tags discussed above, unless you want to use custom diploid types _and_ the built-in fitness policies:</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;struct mloc_fitness {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  typedef double result_type;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  inline double operator()( const multiloc_t::dipvector_t::const_iterator &amp; diploid ) const {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;     using itr_t = multiloc_t::dipvector_t::const_iterator;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;     //Fitness is additive across loci, and loci are additive over mutations:</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;     return std::accumulate( diploid.begin(), diploid.end(), 0, [](const double &amp; w, const itr_t::value_type &amp; __l ) {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;               return w + KTfwd::additive_diploid(__l,2.);</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;       } );</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  }</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;};</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;~~~</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;## Cost vs. benefit</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;The pros of defining your own diploid type are:</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;* Being able to attach data to a diploid genotype beyond the two gametes that it contains.  One can imagine all sorts of things here, but the existing code base may not (yet) support them all.</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;The cons are:</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;* Fitness policies are written differently</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;* In order to use the sugar layer&#39;s streamlined methods for declaring population containers, you must pass your diploid type to those templates (see @ref md_md_sugar).</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;The cons mean that it is not trivial to switch an impementation back and forth between custom and non-custom diploid genotype representations.</div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
