<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: KTfwd Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">KTfwd Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The primary namespace defined by this library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d5/d8a/namespaceKTfwd_1_1experimental"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8a/namespaceKTfwd_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/dbd/namespaceKTfwd_1_1fwdpp__internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dbd/namespaceKTfwd_1_1fwdpp__internal.html">fwdpp_internal</a></td></tr>
<tr class="memdesc:de/dbd/namespaceKTfwd_1_1fwdpp__internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested namespace for nuts and bolts of certain library functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d0a/namespaceKTfwd_1_1sugar"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0a/namespaceKTfwd_1_1sugar.html">sugar</a></td></tr>
<tr class="memdesc:dd/d0a/namespaceKTfwd_1_1sugar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested namespace for sugar layer. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/dea/namespaceKTfwd_1_1tags"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dea/namespaceKTfwd_1_1tags.html">tags</a></td></tr>
<tr class="memdesc:d3/dea/namespaceKTfwd_1_1tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested namespace for dispatch tags for template functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d30/namespaceKTfwd_1_1traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/namespaceKTfwd_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:d0/d30/namespaceKTfwd_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested namespace type traits. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0b/structKTfwd_1_1no__selection.html">no_selection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fitness of 1.  <a href="../../dc/d0b/structKTfwd_1_1no__selection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ddb/structKTfwd_1_1site__dependent__fitness.html">site_dependent_fitness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for fitness as a function of individual mutations in a diploid.  <a href="../../d0/ddb/structKTfwd_1_1site__dependent__fitness.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/structKTfwd_1_1haplotype__dependent__fitness.html">haplotype_dependent_fitness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for fitness as a function of the two haplotypes in a diploid.  <a href="../../de/d99/structKTfwd_1_1haplotype__dependent__fitness.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html">multiplicative_diploid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplicative fitness across sites.  <a href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structKTfwd_1_1additive__diploid.html">additive_diploid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive fitness across sites.  <a href="../../d6/d39/structKTfwd_1_1additive__diploid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html">mutation_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for mutations At minimum, a mutation must contain a position and a count in the population. You can derive from this class, for instance to add selection coefficients, counts in different sexes, etc.  <a href="../../d1/da4/structKTfwd_1_1mutation__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html">mutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest mutation type, adding just a selection coefficient and dominance to the interface.  <a href="../../d1/d7f/structKTfwd_1_1mutation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for gametes.  <a href="../../d6/d90/structKTfwd_1_1gamete__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc3/structKTfwd_1_1n__is__zero.html">n_is_zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if member n == 0 Used internally.  <a href="../../d4/dc3/structKTfwd_1_1n__is__zero.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d1a/structKTfwd_1_1mutation__at__pos.html">mutation_at_pos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if std::fabs(m.pos-d) &lt;= std::numeric_limits&lt;double&gt;::epsilon() Returns true if std::fabs(m.pos-d) &lt;= std::numeric_limits&lt;double&gt;::epsilon()  <a href="../../d5/d1a/structKTfwd_1_1mutation__at__pos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structKTfwd_1_1same__pos.html">same_pos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if std::fabs(m1.pos-m2.pos) &lt;= std::numeric_limits&lt;double&gt;::epsilon() Returns true if std::fabs(m1.pos-m2.pos) &lt;= std::numeric_limits&lt;double&gt;::epsilon()  <a href="../../da/d8f/structKTfwd_1_1same__pos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">equal_eps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if std::max(lhs,rhs)-std::min(lhs,rhs) &lt;= std::numeric_limits&lt;T&gt;::epsilon()  <a href="../../dc/d8e/structKTfwd_1_1equal__eps.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/structKTfwd_1_1mutation__remover.html">mutation_remover</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy determining how mutations are removed from gametes after sampling Policy determining how mutations are removed from gametes after sampling.  <a href="../../d4/de8/structKTfwd_1_1mutation__remover.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structKTfwd_1_1push__back__gamete.html">push_back_gamete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy for gametes.  <a href="../../d1/dcc/structKTfwd_1_1push__back__gamete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dff/structKTfwd_1_1insert__unique.html">insert_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy for gametes.  <a href="../../dd/dff/structKTfwd_1_1insert__unique.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d09/structKTfwd_1_1diploidIOplaceholder.html">diploidIOplaceholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">placeholder IO policy for standard diploid types  <a href="../../d5/d09/structKTfwd_1_1diploidIOplaceholder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5b/structKTfwd_1_1genetics101.html">genetics101</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d55/classKTfwd_1_1GSLrng__t.html">GSLrng_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around gsl_rng * objects.  <a href="../../de/d55/classKTfwd_1_1GSLrng__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d07/structKTfwd_1_1infsites.html">infsites</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function object implementing the infinitely-many sites mutation model for "standard" population-genetic scenarios.  <a href="../../df/d07/structKTfwd_1_1infsites.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/structKTfwd_1_1popgenmut.html">popgenmut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutations with selection, dominance, and tracking age of origin The "standard" mutation type for population genetic simulation. A mutation has its own selection and dominance coefficients.  <a href="../../dc/dcc/structKTfwd_1_1popgenmut.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d25/structKTfwd_1_1mutation__writer.html">mutation_writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates serialization of mutation types supported by the fwdpp sugar library.  <a href="../../de/d25/structKTfwd_1_1mutation__writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1a/structKTfwd_1_1mutation__reader.html">mutation_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates serialization of mutation types supported by the fwdpp sugar library.  <a href="../../d7/d1a/structKTfwd_1_1mutation__reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8e/structKTfwd_1_1serialize.html">serialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize populations.  <a href="../../d0/d8e/structKTfwd_1_1serialize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dde/structKTfwd_1_1deserialize.html">deserialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize population objects.  <a href="../../d6/dde/structKTfwd_1_1deserialize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d04/structKTfwd_1_1gzserialize.html">gzserialize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db3/structKTfwd_1_1gzdeserialize.html">gzdeserialize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga33091eb3417c4c993f3964c278ff30a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d07/group__basicTypes.html#ga33091eb3417c4c993f3964c278ff30a4">gamete</a> = <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt; <a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html">mutation</a> &gt;</td></tr>
<tr class="separator:ga33091eb3417c4c993f3964c278ff30a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb55723569480066b5f03ca9e7ff075"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a4fb55723569480066b5f03ca9e7ff075">GSL_RNG_MT19937</a> = <a class="el" href="../../d7/d43/structKTfwd_1_1sugar_1_1GSL__RNG__TYPE__TAG.html">sugar::GSL_RNG_TYPE_TAG</a>&lt; <a class="el" href="../../de/d6e/group__sugar.html#gga04107baa95fa1f3b160d7618d3369d75a9628b10562b643bff5d84e6dbf17d866">sugar::GSL_RNG_TYPE::MT19937</a> &gt;</td></tr>
<tr class="memdesc:a4fb55723569480066b5f03ca9e7ff075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distpatch tag to signal <a class="el" href="../../de/d55/classKTfwd_1_1GSLrng__t.html" title="A wrapper around gsl_rng * objects. ">GSLrng_t</a> to instantiate in terms of gsl_rng_mt19937.  <a href="#a4fb55723569480066b5f03ca9e7ff075">More...</a><br/></td></tr>
<tr class="separator:a4fb55723569480066b5f03ca9e7ff075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e039b543c1f3b48db094631e2971549"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a7e039b543c1f3b48db094631e2971549">GSL_RNG_TAUS2</a> = <a class="el" href="../../d7/d43/structKTfwd_1_1sugar_1_1GSL__RNG__TYPE__TAG.html">sugar::GSL_RNG_TYPE_TAG</a>&lt; <a class="el" href="../../de/d6e/group__sugar.html#gga04107baa95fa1f3b160d7618d3369d75a1c61b3e6e6203fecfb58277795ad23e0">sugar::GSL_RNG_TYPE::TAUS2</a> &gt;</td></tr>
<tr class="memdesc:a7e039b543c1f3b48db094631e2971549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distpatch tag to signal <a class="el" href="../../de/d55/classKTfwd_1_1GSLrng__t.html" title="A wrapper around gsl_rng * objects. ">GSLrng_t</a> to instantiate in terms of gsl_rng_taus2.  <a href="#a7e039b543c1f3b48db094631e2971549">More...</a><br/></td></tr>
<tr class="separator:a7e039b543c1f3b48db094631e2971549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7166fd30bd57ade0349e85b43f02f915"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a7166fd30bd57ade0349e85b43f02f915"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a7166fd30bd57ade0349e85b43f02f915">metapop_mlist_t</a> = std::list&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;</td></tr>
<tr class="separator:a7166fd30bd57ade0349e85b43f02f915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ab0b722744b27efb71c60da0aae3d6"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a49ab0b722744b27efb71c60da0aae3d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a49ab0b722744b27efb71c60da0aae3d6">metapop_gamete_t</a> = <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a7166fd30bd57ade0349e85b43f02f915">metapop_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;</td></tr>
<tr class="separator:a49ab0b722744b27efb71c60da0aae3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e5161d1603e18b1eea341c59145b1c"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a34e5161d1603e18b1eea341c59145b1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a34e5161d1603e18b1eea341c59145b1c">metapop_glist_t</a> = std::list&lt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#a49ab0b722744b27efb71c60da0aae3d6">metapop_gamete_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt; &gt;</td></tr>
<tr class="separator:a34e5161d1603e18b1eea341c59145b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b0bed2e77578074c133af95e9d3a66"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename diploid_t  = std::pair&lt;typename metapop_glist_t&lt;mtype&gt;::iterator,					  typename metapop_glist_t&lt;mtype&gt;::iterator&gt;&gt; </td></tr>
<tr class="memitem:ga49b0bed2e77578074c133af95e9d3a66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga49b0bed2e77578074c133af95e9d3a66">metapop</a> = <a class="el" href="../../d3/de0/classKTfwd_1_1sugar_1_1metapop.html">sugar::metapop</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a7166fd30bd57ade0349e85b43f02f915">metapop_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a34e5161d1603e18b1eea341c59145b1c">metapop_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt; &gt;, std::vector&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; unsigned &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;&gt;</td></tr>
<tr class="memdesc:ga49b0bed2e77578074c133af95e9d3a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single locus metapopulation simulation without serialization. Cannot be copied, etc. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="../../de/d6e/group__sugar.html#ga49b0bed2e77578074c133af95e9d3a66">More...</a><br/></td></tr>
<tr class="separator:ga49b0bed2e77578074c133af95e9d3a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c6aaf76dded21d719d9197503ea8ae"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename mwriter_t , typename mreader_t , typename diploid_t  = std::pair&lt;typename metapop_glist_t&lt;mtype&gt;::iterator,					  typename metapop_glist_t&lt;mtype&gt;::iterator&gt;, typename diploid_writer_t  = diploidIOplaceholder, typename diploid_reader_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:gaf7c6aaf76dded21d719d9197503ea8ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gaf7c6aaf76dded21d719d9197503ea8ae">metapop_serialized</a> = <a class="el" href="../../d2/d43/classKTfwd_1_1sugar_1_1metapop__serialized.html">sugar::metapop_serialized</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, mwriter_t, mreader_t, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a7166fd30bd57ade0349e85b43f02f915">metapop_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a34e5161d1603e18b1eea341c59145b1c">metapop_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt; &gt;, std::vector&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; unsigned &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;, diploid_writer_t, diploid_reader_t &gt;</td></tr>
<tr class="memdesc:gaf7c6aaf76dded21d719d9197503ea8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single locus metapopulation simulation with serialization. Can be copied, etc. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="../../de/d6e/group__sugar.html#gaf7c6aaf76dded21d719d9197503ea8ae">More...</a><br/></td></tr>
<tr class="separator:gaf7c6aaf76dded21d719d9197503ea8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfa6f797c02d26ac60e49774096829b"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a9cfa6f797c02d26ac60e49774096829b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9cfa6f797c02d26ac60e49774096829b">multiloc_mlist_t</a> = std::list&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;</td></tr>
<tr class="separator:a9cfa6f797c02d26ac60e49774096829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40afd65fd9ec426bfef16969d7c8c1c4"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a40afd65fd9ec426bfef16969d7c8c1c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a40afd65fd9ec426bfef16969d7c8c1c4">multiloc_gamete_t</a> = <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9cfa6f797c02d26ac60e49774096829b">multiloc_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;</td></tr>
<tr class="separator:a40afd65fd9ec426bfef16969d7c8c1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b6af326e670138f1077b17be3c8038"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a28b6af326e670138f1077b17be3c8038"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a28b6af326e670138f1077b17be3c8038">multiloc_glist_t</a> = std::list&lt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#a40afd65fd9ec426bfef16969d7c8c1c4">multiloc_gamete_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;</td></tr>
<tr class="separator:a28b6af326e670138f1077b17be3c8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce0e5a9ecd3ba04a4ec5441f13532d8"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename diploid_t  = std::pair&lt;typename multiloc_glist_t&lt;mtype&gt;::iterator,					  typename multiloc_glist_t&lt;mtype&gt;::iterator&gt;&gt; </td></tr>
<tr class="memitem:gabce0e5a9ecd3ba04a4ec5441f13532d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gabce0e5a9ecd3ba04a4ec5441f13532d8">multiloc</a> = <a class="el" href="../../d3/d11/structKTfwd_1_1sugar_1_1multiloc.html">sugar::multiloc</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9cfa6f797c02d26ac60e49774096829b">multiloc_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a28b6af326e670138f1077b17be3c8038">multiloc_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;&gt;, std::vector&lt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#a28b6af326e670138f1077b17be3c8038">multiloc_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;, std::vector&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; unsigned &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;&gt;</td></tr>
<tr class="memdesc:gabce0e5a9ecd3ba04a4ec5441f13532d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single population, multilocus simulation without serialization. Cannot be copied, etc. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="../../de/d6e/group__sugar.html#gabce0e5a9ecd3ba04a4ec5441f13532d8">More...</a><br/></td></tr>
<tr class="separator:gabce0e5a9ecd3ba04a4ec5441f13532d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade651e70b4a2357c1e686393c67dcdf5"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename mwriter , typename mreader , typename diploid_t  = std::pair&lt;typename multiloc_glist_t&lt;mtype&gt;::iterator,					  typename multiloc_glist_t&lt;mtype&gt;::iterator&gt;, typename diploid_writer_t  = diploidIOplaceholder, typename diploid_reader_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:gade651e70b4a2357c1e686393c67dcdf5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gade651e70b4a2357c1e686393c67dcdf5">multiloc_serialized</a> = <a class="el" href="../../d0/dc0/structKTfwd_1_1sugar_1_1multiloc__serialized.html">sugar::multiloc_serialized</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../d0/db9/sugar1_8cc.html#adc4cb78b331fc4385057a2f785457cae">mwriter</a>, <a class="el" href="../../d0/db9/sugar1_8cc.html#ac02910b52cd45b9a8fd7e32d4ebfe46b">mreader</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9cfa6f797c02d26ac60e49774096829b">multiloc_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a28b6af326e670138f1077b17be3c8038">multiloc_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;&gt;, std::vector&lt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#a28b6af326e670138f1077b17be3c8038">multiloc_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;, std::vector&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; unsigned &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;, diploid_writer_t, diploid_reader_t &gt;</td></tr>
<tr class="memdesc:gade651e70b4a2357c1e686393c67dcdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single population, multilocus simulation with serialization. Can be copied, etc. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="../../de/d6e/group__sugar.html#gade651e70b4a2357c1e686393c67dcdf5">More...</a><br/></td></tr>
<tr class="separator:gade651e70b4a2357c1e686393c67dcdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae4c7f1ef9dd1bd058811d3e2a69914"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a4ae4c7f1ef9dd1bd058811d3e2a69914"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a4ae4c7f1ef9dd1bd058811d3e2a69914">singlepop_mlist_t</a> = std::list&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, std::allocator&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt; &gt;</td></tr>
<tr class="separator:a4ae4c7f1ef9dd1bd058811d3e2a69914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e0deaaa7ec5b04c0a6bb8beb654b99"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a08e0deaaa7ec5b04c0a6bb8beb654b99"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a08e0deaaa7ec5b04c0a6bb8beb654b99">singlepop_gamete_t</a> = <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a4ae4c7f1ef9dd1bd058811d3e2a69914">singlepop_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;</td></tr>
<tr class="separator:a08e0deaaa7ec5b04c0a6bb8beb654b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b9cc59d4daf5acf3e25d92e5c9b253"><td class="memTemplParams" colspan="2">template&lt;typename mtype &gt; </td></tr>
<tr class="memitem:a55b9cc59d4daf5acf3e25d92e5c9b253"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a55b9cc59d4daf5acf3e25d92e5c9b253">singlepop_glist_t</a> = std::list&lt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#a08e0deaaa7ec5b04c0a6bb8beb654b99">singlepop_gamete_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::allocator&lt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#a08e0deaaa7ec5b04c0a6bb8beb654b99">singlepop_gamete_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;&gt;&gt;</td></tr>
<tr class="separator:a55b9cc59d4daf5acf3e25d92e5c9b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d9294290e82fd816141196a6fb5571"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename diploid_t  = std::pair&lt;typename singlepop_glist_t&lt;mtype&gt;::iterator,					  typename singlepop_glist_t&lt;mtype&gt;::iterator&gt;&gt; </td></tr>
<tr class="memitem:ga48d9294290e82fd816141196a6fb5571"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga48d9294290e82fd816141196a6fb5571">singlepop</a> = <a class="el" href="../../d5/d74/classKTfwd_1_1sugar_1_1singlepop.html">sugar::singlepop</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a4ae4c7f1ef9dd1bd058811d3e2a69914">singlepop_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a55b9cc59d4daf5acf3e25d92e5c9b253">singlepop_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;, std::vector&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; unsigned &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga48d9294290e82fd816141196a6fb5571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single locus, single population without serialization. Cannot be copied, etc. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="../../de/d6e/group__sugar.html#ga48d9294290e82fd816141196a6fb5571">More...</a><br/></td></tr>
<tr class="separator:ga48d9294290e82fd816141196a6fb5571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c218b55653f2425a8701951ab16be1c"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename mwriter_t , typename mreader_t , typename diploid_t  = std::pair&lt;typename singlepop_glist_t&lt;mtype&gt;::iterator,					  typename singlepop_glist_t&lt;mtype&gt;::iterator&gt;, typename diploid_writer_t  = diploidIOplaceholder, typename diploid_reader_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:ga8c218b55653f2425a8701951ab16be1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga8c218b55653f2425a8701951ab16be1c">singlepop_serialized</a> = <a class="el" href="../../d9/dee/classKTfwd_1_1sugar_1_1singlepop__serialized.html">sugar::singlepop_serialized</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>, mwriter_t, mreader_t, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a4ae4c7f1ef9dd1bd058811d3e2a69914">singlepop_mlist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, <a class="el" href="../../da/d8b/namespaceKTfwd.html#a55b9cc59d4daf5acf3e25d92e5c9b253">singlepop_glist_t</a>&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;, std::vector&lt; <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a> &gt;, std::vector&lt; unsigned &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;, diploid_writer_t, diploid_reader_t &gt;</td></tr>
<tr class="memdesc:ga8c218b55653f2425a8701951ab16be1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single locus, single population with serialization. Can be copied, etc. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="../../de/d6e/group__sugar.html#ga8c218b55653f2425a8701951ab16be1c">More...</a><br/></td></tr>
<tr class="separator:ga8c218b55653f2425a8701951ab16be1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a728e20cb60f82b818b5cc570722079a4"><td class="memTemplParams" colspan="2">template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a728e20cb60f82b818b5cc570722079a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a728e20cb60f82b818b5cc570722079a4">check_sum</a> (const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;gametes, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:a728e20cb60f82b818b5cc570722079a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise.  <a href="#a728e20cb60f82b818b5cc570722079a4">More...</a><br/></td></tr>
<tr class="separator:a728e20cb60f82b818b5cc570722079a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a49997b8e11c148177adea58dd916a6"><td class="memTemplParams" colspan="2">template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a3a49997b8e11c148177adea58dd916a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a3a49997b8e11c148177adea58dd916a6">check_sum</a> (const vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:a3a49997b8e11c148177adea58dd916a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise.  <a href="#a3a49997b8e11c148177adea58dd916a6">More...</a><br/></td></tr>
<tr class="separator:a3a49997b8e11c148177adea58dd916a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a46b107991548a40821e132496c1693"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename recombination_map , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a8a46b107991548a40821e132496c1693"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a8a46b107991548a40821e132496c1693">recombine_gametes</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const double &amp;littler, list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *gametes, iterator_type &amp;g1, iterator_type &amp;g2, const recombination_map &amp;mf)</td></tr>
<tr class="memdesc:a8a46b107991548a40821e132496c1693"><td class="mdescLeft">&#160;</td><td class="mdescRight">recombination for individual-based forward simulations  <a href="#a8a46b107991548a40821e132496c1693">More...</a><br/></td></tr>
<tr class="separator:a8a46b107991548a40821e132496c1693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758ef2a67e1fbb768640e533377f506"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename list_type_allocator , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:ad758ef2a67e1fbb768640e533377f506"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad758ef2a67e1fbb768640e533377f506">recombine_gametes</a> (const vector_type&lt; double, vector_type_allocator &gt; &amp;pos, list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *gametes, iterator_type &amp;g1, iterator_type &amp;g2)</td></tr>
<tr class="separator:ad758ef2a67e1fbb768640e533377f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18df6351fa3148914bbb844c36bc3e05"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </td></tr>
<tr class="memitem:a18df6351fa3148914bbb844c36bc3e05"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a18df6351fa3148914bbb844c36bc3e05">sample_diploid</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N_curr, const double &amp;mu, const mutation_model &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0)</td></tr>
<tr class="separator:a18df6351fa3148914bbb844c36bc3e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bfd39cb9e480156946dc9969bde8e6"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </td></tr>
<tr class="memitem:a37bfd39cb9e480156946dc9969bde8e6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a37bfd39cb9e480156946dc9969bde8e6">sample_diploid</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N_curr, const unsigned &amp;N_next, const double &amp;mu, const mutation_model &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0)</td></tr>
<tr class="separator:a37bfd39cb9e480156946dc9969bde8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc3d0dbb6b092f56ba18331751af77"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </td></tr>
<tr class="memitem:a44bc3d0dbb6b092f56ba18331751af77"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a44bc3d0dbb6b092f56ba18331751af77">sample_diploid</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *<a class="el" href="../../de/d6e/group__sugar.html#ga49b0bed2e77578074c133af95e9d3a66">metapop</a>, metapop_diploid_vector_type&lt; diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned *N_curr, const double &amp;mu, const mutation_model &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp, const migration_policy &amp;mig, const double *f=nullptr)</td></tr>
<tr class="separator:a44bc3d0dbb6b092f56ba18331751af77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad592697866c4bacdf00ccb6e902c0891"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </td></tr>
<tr class="memitem:ad592697866c4bacdf00ccb6e902c0891"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad592697866c4bacdf00ccb6e902c0891">sample_diploid</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *<a class="el" href="../../de/d6e/group__sugar.html#ga49b0bed2e77578074c133af95e9d3a66">metapop</a>, metapop_diploid_vector_type&lt; diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned *N_curr, const unsigned *N_next, const double &amp;mu, const mutation_model &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp, const migration_policy &amp;mig, const double *f=nullptr)</td></tr>
<tr class="memdesc:ad592697866c4bacdf00ccb6e902c0891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evolve a metapopulation where demes may be changing size. For individual-based sims. Evolve a metapopulation where demes may be changing size. For individual-based sims.  <a href="#ad592697866c4bacdf00ccb6e902c0891">More...</a><br/></td></tr>
<tr class="separator:ad592697866c4bacdf00ccb6e902c0891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b321ba63144739f7a25675da26bf02"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , typename bw_locus_rec_fxn , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </td></tr>
<tr class="memitem:ab9b321ba63144739f7a25675da26bf02"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ab9b321ba63144739f7a25675da26bf02">sample_diploid</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *gametes, diploid_vector_type&lt; locus_vector_type&lt; diploid_geno_t, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N_curr, const unsigned &amp;N_next, const double *mu, const mutation_model_container &amp;mmodel, const recombination_policy_container &amp;rec_policies, const double *r_between_loci, const bw_locus_rec_fxn &amp;blrf, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0)</td></tr>
<tr class="memdesc:ab9b321ba63144739f7a25675da26bf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single deme, multilocus model, changing population size.  <a href="#ab9b321ba63144739f7a25675da26bf02">More...</a><br/></td></tr>
<tr class="separator:ab9b321ba63144739f7a25675da26bf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe562b17f78f17b16d477ae93a5c2eb8"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , typename bw_locus_rec_fxn , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </td></tr>
<tr class="memitem:afe562b17f78f17b16d477ae93a5c2eb8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#afe562b17f78f17b16d477ae93a5c2eb8">sample_diploid</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *gametes, diploid_vector_type&lt; locus_vector_type&lt; diploid_geno_t, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N, const double *mu, const mutation_model_container &amp;mmodel, const recombination_policy_container &amp;rec_policies, const double *r_between_loci, const bw_locus_rec_fxn &amp;blrf, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0)</td></tr>
<tr class="separator:afe562b17f78f17b16d477ae93a5c2eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a292a1e5c591d64d14caf4062e2f3"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename fitness_updating_policy_hom , typename fitness_updating_policy_het &gt; </td></tr>
<tr class="memitem:a105a292a1e5c591d64d14caf4062e2f3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a105a292a1e5c591d64d14caf4062e2f3">site_dependent_fitness2</a> (iterator_type __first1, iterator_type __last1, iterator_type __first2, iterator_type __last2, const fitness_updating_policy_hom &amp;fpol_hom, const fitness_updating_policy_het &amp;fpol_het, const double &amp;starting_fitness=1.)</td></tr>
<tr class="separator:a105a292a1e5c591d64d14caf4062e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05d39195307329f16205963a265b41f"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_allocator_type , typename mutation_type , typename list_allocator_type , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:af05d39195307329f16205963a265b41f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#af05d39195307329f16205963a265b41f">init_with_ms</a> (Sequence::SimData &amp;d, vector_type&lt; gamete_type, vector_allocator_type &gt; *gametes, list_type&lt; mutation_type, list_allocator_type &gt; *mutations, const unsigned &amp;max_chroms=std::numeric_limits&lt; unsigned &gt;::max())</td></tr>
<tr class="memdesc:af05d39195307329f16205963a265b41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a population with results from a coalescent simulation Takes an object of type Sequence::SimData from libsequence and initialized a population.  <a href="#af05d39195307329f16205963a265b41f">More...</a><br/></td></tr>
<tr class="separator:af05d39195307329f16205963a265b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06ca8dade5d8e9af09e117e403bf644"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:ac06ca8dade5d8e9af09e117e403bf644"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ac06ca8dade5d8e9af09e117e403bf644">insert_at_end</a> (T &amp;&amp;t, cT *ct)</td></tr>
<tr class="memdesc:ac06ca8dade5d8e9af09e117e403bf644"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#ac06ca8dade5d8e9af09e117e403bf644">More...</a><br/></td></tr>
<tr class="separator:ac06ca8dade5d8e9af09e117e403bf644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258eb02c9748d27f8793e431c999feea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a258eb02c9748d27f8793e431c999feea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a258eb02c9748d27f8793e431c999feea">push_at_end</a> (T &amp;&amp;t, cT *ct)</td></tr>
<tr class="memdesc:a258eb02c9748d27f8793e431c999feea"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy Works via push_back instead of insert, so there is no return value.  <a href="#a258eb02c9748d27f8793e431c999feea">More...</a><br/></td></tr>
<tr class="separator:a258eb02c9748d27f8793e431c999feea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6270abe1bf379c5458a3d09bc99455"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a5f6270abe1bf379c5458a3d09bc99455"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a5f6270abe1bf379c5458a3d09bc99455">update_if_exists_insert</a> (T &amp;&amp;t, cT *ct)</td></tr>
<tr class="memdesc:a5f6270abe1bf379c5458a3d09bc99455"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#a5f6270abe1bf379c5458a3d09bc99455">More...</a><br/></td></tr>
<tr class="separator:a5f6270abe1bf379c5458a3d09bc99455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9791ec9905f663089b0a52d4facb0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a1c9791ec9905f663089b0a52d4facb0d"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a1c9791ec9905f663089b0a52d4facb0d">insert_if_not_found</a> (T &amp;&amp;t, cT *ct)</td></tr>
<tr class="separator:a1c9791ec9905f663089b0a52d4facb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2fd01e4b5a2bdcadb5e7c4382bb4d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:afb2fd01e4b5a2bdcadb5e7c4382bb4d2"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#afb2fd01e4b5a2bdcadb5e7c4382bb4d2">insert_if_not_found</a> (T &amp;&amp;t, cT *ct, const unsigned &amp;n)</td></tr>
<tr class="separator:afb2fd01e4b5a2bdcadb5e7c4382bb4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f12d7c4af0b0d5b6dc48772d1cae49d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a4f12d7c4af0b0d5b6dc48772d1cae49d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a4f12d7c4af0b0d5b6dc48772d1cae49d">update_if_exists_push</a> (T &amp;&amp;t, cT *ct)</td></tr>
<tr class="memdesc:a4f12d7c4af0b0d5b6dc48772d1cae49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#a4f12d7c4af0b0d5b6dc48772d1cae49d">More...</a><br/></td></tr>
<tr class="separator:a4f12d7c4af0b0d5b6dc48772d1cae49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be41eec381fecf3eb936bb1f7ef19af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a8be41eec381fecf3eb936bb1f7ef19af"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a8be41eec381fecf3eb936bb1f7ef19af">insert_new_or_fail</a> (T &amp;&amp;t, cT *ct)</td></tr>
<tr class="memdesc:a8be41eec381fecf3eb936bb1f7ef19af"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#a8be41eec381fecf3eb936bb1f7ef19af">More...</a><br/></td></tr>
<tr class="separator:a8be41eec381fecf3eb936bb1f7ef19af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c5d5579cbb54c0f0dffdf57e0d9b9"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type &gt; </td></tr>
<tr class="memitem:a851c5d5579cbb54c0f0dffdf57e0d9b9"><td class="memTemplItemLeft" align="right" valign="top">list_type::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a851c5d5579cbb54c0f0dffdf57e0d9b9">insert_mutation_at_end</a> (mutation_type &amp;&amp;m, list_type *mutations)</td></tr>
<tr class="memdesc:a851c5d5579cbb54c0f0dffdf57e0d9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion policy for a mutation.  <a href="#a851c5d5579cbb54c0f0dffdf57e0d9b9">More...</a><br/></td></tr>
<tr class="separator:a851c5d5579cbb54c0f0dffdf57e0d9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad884f819fe299dbf52d65253e21c1d17"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type &gt; </td></tr>
<tr class="memitem:ad884f819fe299dbf52d65253e21c1d17"><td class="memTemplItemLeft" align="right" valign="top">list_type::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad884f819fe299dbf52d65253e21c1d17">insert_unique_or_fail</a> (mutation_type &amp;&amp;m, list_type *mutations)</td></tr>
<tr class="separator:ad884f819fe299dbf52d65253e21c1d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4826160f7e99b8c2cdb7fa2769c6aeeb"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_writer_type , typename ostreamtype , typename diploid_writer_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:a4826160f7e99b8c2cdb7fa2769c6aeeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a4826160f7e99b8c2cdb7fa2769c6aeeb">write_binary_pop</a> (const gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, const mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, const diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt; *diploids, const mutation_writer_type &amp;mw, ostreamtype &amp;buffer, const diploid_writer_t &amp;dw=diploid_writer_t())</td></tr>
<tr class="memdesc:a4826160f7e99b8c2cdb7fa2769c6aeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write population to binary-format file for individual-based simulations.  <a href="#a4826160f7e99b8c2cdb7fa2769c6aeeb">More...</a><br/></td></tr>
<tr class="separator:a4826160f7e99b8c2cdb7fa2769c6aeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ddb3ab8a5d762b4feda87205ad2253"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_reader_type , typename istreamtype , typename diploid_reader_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:af5ddb3ab8a5d762b4feda87205ad2253"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#af5ddb3ab8a5d762b4feda87205ad2253">read_binary_pop</a> (gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, istreamtype &amp;in, const diploid_reader_t &amp;dr=diploid_reader_t())</td></tr>
<tr class="memdesc:af5ddb3ab8a5d762b4feda87205ad2253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the population back from a binary-format file for individual-based simulations.  <a href="#af5ddb3ab8a5d762b4feda87205ad2253">More...</a><br/></td></tr>
<tr class="separator:af5ddb3ab8a5d762b4feda87205ad2253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a4a3be11d90ac32a75618ccf24a8a"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mlocus_vector_type_allocator , template&lt; typename, typename &gt; class mlocus_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_writer_type , typename ostreamtype , typename diploid_writer_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:a155a4a3be11d90ac32a75618ccf24a8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a155a4a3be11d90ac32a75618ccf24a8a">write_binary_pop</a> (const mlocus_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, mlocus_vector_type_allocator &gt; *mlocus_gametes, const mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, const diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_writer_type &amp;mw, ostreamtype &amp;buffer, const diploid_writer_t &amp;dw=diploid_writer_t())</td></tr>
<tr class="memdesc:a155a4a3be11d90ac32a75618ccf24a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the population to a binary-format file for individual-based multilocus simulations.  <a href="#a155a4a3be11d90ac32a75618ccf24a8a">More...</a><br/></td></tr>
<tr class="separator:a155a4a3be11d90ac32a75618ccf24a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ea92a126bcb9616e9c6a0207760774"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mlocus_vector_type_allocator , template&lt; typename, typename &gt; class mlocus_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type , typename istreamtype , typename diploid_reader_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:af1ea92a126bcb9616e9c6a0207760774"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#af1ea92a126bcb9616e9c6a0207760774">read_binary_pop</a> (mlocus_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, mlocus_vector_type_allocator &gt; *mlocus_gametes, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, istreamtype &amp;in, const diploid_reader_t &amp;dr=diploid_reader_t())</td></tr>
<tr class="memdesc:af1ea92a126bcb9616e9c6a0207760774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the population back from a binary-format file for individual-based multilocus simulations.  <a href="#af1ea92a126bcb9616e9c6a0207760774">More...</a><br/></td></tr>
<tr class="separator:af1ea92a126bcb9616e9c6a0207760774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f60cccc4f91b8d9695a4d9abf300a"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_writer_type , typename ostreamtype , typename diploid_writer_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:ab62f60cccc4f91b8d9695a4d9abf300a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ab62f60cccc4f91b8d9695a4d9abf300a">write_binary_metapop</a> (const gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *<a class="el" href="../../de/d6e/group__sugar.html#ga49b0bed2e77578074c133af95e9d3a66">metapop</a>, const mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, const diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_writer_type &amp;mw, ostreamtype &amp;buffer, const diploid_writer_t &amp;dw=diploid_writer_t())</td></tr>
<tr class="separator:ab62f60cccc4f91b8d9695a4d9abf300a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be2b56dc9917b88ed0a91ce7a3c6bb5"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type , typename istreamtype , typename diploid_reader_t  = diploidIOplaceholder&gt; </td></tr>
<tr class="memitem:a3be2b56dc9917b88ed0a91ce7a3c6bb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a3be2b56dc9917b88ed0a91ce7a3c6bb5">read_binary_metapop</a> (gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, istreamtype &amp;in, const diploid_reader_t &amp;dr=diploid_reader_t())</td></tr>
<tr class="memdesc:a3be2b56dc9917b88ed0a91ce7a3c6bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the metapopulation back from a binary-format file for individual-based simulations Read the metapopulation back from a binary-format file.  <a href="#a3be2b56dc9917b88ed0a91ce7a3c6bb5">More...</a><br/></td></tr>
<tr class="separator:a3be2b56dc9917b88ed0a91ce7a3c6bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949b79d4df5bc10c6c1b31d311e4a392"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename mutation_model , typename mutation_insertion_policy , typename gamete_insertion_policy , typename list_type_allocator , typename list_type_allocator2 , template&lt; typename, typename &gt; class list_type, template&lt; typename, typename &gt; class list_type2&gt; </td></tr>
<tr class="memitem:a949b79d4df5bc10c6c1b31d311e4a392"><td class="memTemplItemLeft" align="right" valign="top">iterator_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a949b79d4df5bc10c6c1b31d311e4a392">mutate_gamete</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const double &amp;mu, list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *gametes, list_type2&lt; typename iterator_type::value_type::mutation_type, list_type_allocator2 &gt; *mutations, iterator_type &amp;g, const mutation_model &amp;mmodel, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy)</td></tr>
<tr class="memdesc:a949b79d4df5bc10c6c1b31d311e4a392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply mutation model to an individual gamete. Used for individual-based forward simulations.  <a href="#a949b79d4df5bc10c6c1b31d311e4a392">More...</a><br/></td></tr>
<tr class="separator:a949b79d4df5bc10c6c1b31d311e4a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4ac5932b4c1d311486946b2b6f612c"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type &gt; </td></tr>
<tr class="memitem:a2b4ac5932b4c1d311486946b2b6f612c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a2b4ac5932b4c1d311486946b2b6f612c">population_sfs</a> (iterator_type beg, iterator_type end, const unsigned &amp;N)</td></tr>
<tr class="separator:a2b4ac5932b4c1d311486946b2b6f612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9d58d1446e2d4a5aae1e5c4e7ba946"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename allocator_t , template&lt; typename, typename &gt; class container_t&gt; </td></tr>
<tr class="memitem:a9d9d58d1446e2d4a5aae1e5c4e7ba946"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9d9d58d1446e2d4a5aae1e5c4e7ba946">sample_sfs</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const container_t&lt; gamete_type, allocator_t &gt; &amp;gametes, const unsigned &amp;n, const unsigned &amp;N)</td></tr>
<tr class="separator:a9d9d58d1446e2d4a5aae1e5c4e7ba946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9aee81e0abaddbb9c6e56f0d8f980f"><td class="memTemplParams" colspan="2">template&lt;typename allocator , typename diploid_geno_t , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:ga2e9aee81e0abaddbb9c6e56f0d8f980f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of<br class="typebreak"/>
&lt; <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html">mutation_base</a>, typename <br class="typebreak"/>
diploid_geno_t::first_type::value_type::mutation_type &gt;<br class="typebreak"/>
::value, std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de2/group__samplingPopsInd.html#ga2e9aee81e0abaddbb9c6e56f0d8f980f">ms_sample</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const vector_type&lt; diploid_geno_t, allocator &gt; *diploids, const unsigned &amp;n, const bool &amp;remove_fixed=true)</td></tr>
<tr class="memdesc:ga2e9aee81e0abaddbb9c6e56f0d8f980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling from a population in an individual-based simulation.  <a href="../../d7/de2/group__samplingPopsInd.html#ga2e9aee81e0abaddbb9c6e56f0d8f980f">More...</a><br/></td></tr>
<tr class="separator:ga2e9aee81e0abaddbb9c6e56f0d8f980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235b4507a6f09b26fa9b33ef12abf59d"><td class="memTemplParams" colspan="2">template&lt;typename allocator , typename diploid_geno_t , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:ga235b4507a6f09b26fa9b33ef12abf59d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of<br class="typebreak"/>
&lt; <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html">mutation_base</a>, typename <br class="typebreak"/>
diploid_geno_t::first_type::value_type::mutation_type &gt;<br class="typebreak"/>
::value, std::pair<br class="typebreak"/>
&lt; std::vector&lt; std::pair<br class="typebreak"/>
&lt; double, std::string &gt;<br class="typebreak"/>
 &gt;, std::vector&lt; std::pair<br class="typebreak"/>
&lt; double, std::string &gt;<br class="typebreak"/>
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de2/group__samplingPopsInd.html#ga235b4507a6f09b26fa9b33ef12abf59d">ms_sample_separate</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const vector_type&lt; diploid_geno_t, allocator &gt; *diploids, const unsigned &amp;n, const bool &amp;remove_fixed=true)</td></tr>
<tr class="memdesc:ga235b4507a6f09b26fa9b33ef12abf59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling from a population in an individual-based simulation. Selected and neutral mutations returned separately.  <a href="../../d7/de2/group__samplingPopsInd.html#ga235b4507a6f09b26fa9b33ef12abf59d">More...</a><br/></td></tr>
<tr class="separator:ga235b4507a6f09b26fa9b33ef12abf59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb40e7f5643e231bdd887839c4eae37"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename allocator , typename outer_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class outer_vector_type&gt; </td></tr>
<tr class="memitem:ga9eb40e7f5643e231bdd887839c4eae37"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of<br class="typebreak"/>
&lt; <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html">mutation_base</a>, typename <br class="typebreak"/>
diploid_geno_t::first_type::value_type::mutation_type &gt;<br class="typebreak"/>
::value, std::vector<br class="typebreak"/>
&lt; std::vector&lt; std::pair<br class="typebreak"/>
&lt; double, std::string &gt;<br class="typebreak"/>
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de2/group__samplingPopsInd.html#ga9eb40e7f5643e231bdd887839c4eae37">ms_sample</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const outer_vector_type&lt; vector_type&lt; diploid_geno_t, allocator &gt;, outer_allocator &gt; *diploids, const unsigned &amp;n, const bool &amp;remove_fixed)</td></tr>
<tr class="memdesc:ga9eb40e7f5643e231bdd887839c4eae37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample from an individual-based, multi-locus simulation.  <a href="../../d7/de2/group__samplingPopsInd.html#ga9eb40e7f5643e231bdd887839c4eae37">More...</a><br/></td></tr>
<tr class="separator:ga9eb40e7f5643e231bdd887839c4eae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0224ebf0ff72612c74f449b63d507f"><td class="memTemplParams" colspan="2">template&lt;typename diploid_geno_t , typename allocator , typename outer_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class outer_vector_type&gt; </td></tr>
<tr class="memitem:ga0b0224ebf0ff72612c74f449b63d507f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of<br class="typebreak"/>
&lt; <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html">mutation_base</a>, typename <br class="typebreak"/>
diploid_geno_t::first_type::value_type::mutation_type &gt;<br class="typebreak"/>
::value, std::vector<br class="typebreak"/>
&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt;, std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de2/group__samplingPopsInd.html#ga0b0224ebf0ff72612c74f449b63d507f">ms_sample_separate</a> (gsl_rng *<a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>, const outer_vector_type&lt; vector_type&lt; diploid_geno_t, allocator &gt;, outer_allocator &gt; *diploids, const unsigned &amp;n, const bool &amp;remove_fixed)</td></tr>
<tr class="memdesc:ga0b0224ebf0ff72612c74f449b63d507f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample from an individual-based, multi-locus simulation.  <a href="../../d7/de2/group__samplingPopsInd.html#ga0b0224ebf0ff72612c74f449b63d507f">More...</a><br/></td></tr>
<tr class="separator:ga0b0224ebf0ff72612c74f449b63d507f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ac7525d84cfec32e3007029da92cee"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a91ac7525d84cfec32e3007029da92cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a91ac7525d84cfec32e3007029da92cee">uncheck</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations)</td></tr>
<tr class="separator:a91ac7525d84cfec32e3007029da92cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a86a4fcecb15c101816ccdd15eefd6a1b">remove_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations)</td></tr>
<tr class="memdesc:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mutations from population Removes mutations that are lost.  <a href="#a86a4fcecb15c101816ccdd15eefd6a1b">More...</a><br/></td></tr>
<tr class="separator:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73eeda26047df89b8ea303c0d8a6b74"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </td></tr>
<tr class="memitem:ad73eeda26047df89b8ea303c0d8a6b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad73eeda26047df89b8ea303c0d8a6b74">remove_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations, mutation_lookup_table *lookup)</td></tr>
<tr class="memdesc:ad73eeda26047df89b8ea303c0d8a6b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mutations from population Removes mutations that are lost.  <a href="#ad73eeda26047df89b8ea303c0d8a6b74">More...</a><br/></td></tr>
<tr class="separator:ad73eeda26047df89b8ea303c0d8a6b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e666ea27d38bdfc539ffd23653eaa9"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a84e666ea27d38bdfc539ffd23653eaa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a84e666ea27d38bdfc539ffd23653eaa9">remove_fixed_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations, vector_type&lt; mutation_type, vector_type_allocator1 &gt; *fixations, vector_type&lt; unsigned, vector_type_allocator2 &gt; *fixation_times, const unsigned &amp;generation, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:a84e666ea27d38bdfc539ffd23653eaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mutations from population Removes mutations that are fixed or lost.  <a href="#a84e666ea27d38bdfc539ffd23653eaa9">More...</a><br/></td></tr>
<tr class="separator:a84e666ea27d38bdfc539ffd23653eaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc0bd4b96e6164ec339823c85de235e"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </td></tr>
<tr class="memitem:adbc0bd4b96e6164ec339823c85de235e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#adbc0bd4b96e6164ec339823c85de235e">remove_fixed_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations, vector_type&lt; mutation_type, vector_type_allocator1 &gt; *fixations, vector_type&lt; unsigned, vector_type_allocator2 &gt; *fixation_times, mutation_lookup_table *lookup, const unsigned &amp;generation, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:adbc0bd4b96e6164ec339823c85de235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mutations from population Removes mutations that are fixed or lost.  <a href="#adbc0bd4b96e6164ec339823c85de235e">More...</a><br/></td></tr>
<tr class="separator:adbc0bd4b96e6164ec339823c85de235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f8145754db271c7c696293de00ee9"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type &gt; </td></tr>
<tr class="memitem:af72f8145754db271c7c696293de00ee9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#af72f8145754db271c7c696293de00ee9">adjust_mutation_counts</a> (iterator_type &amp;g, const unsigned &amp;n)</td></tr>
<tr class="memdesc:af72f8145754db271c7c696293de00ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">used internally  <a href="#af72f8145754db271c7c696293de00ee9">More...</a><br/></td></tr>
<tr class="separator:af72f8145754db271c7c696293de00ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The primary namespace defined by this library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4fb55723569480066b5f03ca9e7ff075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a4fb55723569480066b5f03ca9e7ff075">KTfwd::GSL_RNG_MT19937</a> = typedef <a class="el" href="../../d7/d43/structKTfwd_1_1sugar_1_1GSL__RNG__TYPE__TAG.html">sugar::GSL_RNG_TYPE_TAG</a>&lt;<a class="el" href="../../de/d6e/group__sugar.html#gga04107baa95fa1f3b160d7618d3369d75a9628b10562b643bff5d84e6dbf17d866">sugar::GSL_RNG_TYPE::MT19937</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distpatch tag to signal <a class="el" href="../../de/d55/classKTfwd_1_1GSLrng__t.html" title="A wrapper around gsl_rng * objects. ">GSLrng_t</a> to instantiate in terms of gsl_rng_mt19937. </p>

</div>
</div>
<a class="anchor" id="a7e039b543c1f3b48db094631e2971549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a7e039b543c1f3b48db094631e2971549">KTfwd::GSL_RNG_TAUS2</a> = typedef <a class="el" href="../../d7/d43/structKTfwd_1_1sugar_1_1GSL__RNG__TYPE__TAG.html">sugar::GSL_RNG_TYPE_TAG</a>&lt;<a class="el" href="../../de/d6e/group__sugar.html#gga04107baa95fa1f3b160d7618d3369d75a1c61b3e6e6203fecfb58277795ad23e0">sugar::GSL_RNG_TYPE::TAUS2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distpatch tag to signal <a class="el" href="../../de/d55/classKTfwd_1_1GSLrng__t.html" title="A wrapper around gsl_rng * objects. ">GSLrng_t</a> to instantiate in terms of gsl_rng_taus2. </p>

</div>
</div>
<a class="anchor" id="a49ab0b722744b27efb71c60da0aae3d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a49ab0b722744b27efb71c60da0aae3d6">KTfwd::metapop_gamete_t</a> = typedef <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>,<a class="el" href="../../da/d8b/namespaceKTfwd.html#a7166fd30bd57ade0349e85b43f02f915">metapop_mlist_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34e5161d1603e18b1eea341c59145b1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a34e5161d1603e18b1eea341c59145b1c">KTfwd::metapop_glist_t</a> = typedef std::list&lt;<a class="el" href="../../da/d8b/namespaceKTfwd.html#a49ab0b722744b27efb71c60da0aae3d6">metapop_gamete_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7166fd30bd57ade0349e85b43f02f915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a7166fd30bd57ade0349e85b43f02f915">KTfwd::metapop_mlist_t</a> = typedef std::list&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40afd65fd9ec426bfef16969d7c8c1c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a40afd65fd9ec426bfef16969d7c8c1c4">KTfwd::multiloc_gamete_t</a> = typedef <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>,<a class="el" href="../../da/d8b/namespaceKTfwd.html#a9cfa6f797c02d26ac60e49774096829b">multiloc_mlist_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28b6af326e670138f1077b17be3c8038"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a28b6af326e670138f1077b17be3c8038">KTfwd::multiloc_glist_t</a> = typedef std::list&lt;<a class="el" href="../../da/d8b/namespaceKTfwd.html#a40afd65fd9ec426bfef16969d7c8c1c4">multiloc_gamete_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cfa6f797c02d26ac60e49774096829b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a9cfa6f797c02d26ac60e49774096829b">KTfwd::multiloc_mlist_t</a> = typedef std::list&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a08e0deaaa7ec5b04c0a6bb8beb654b99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a08e0deaaa7ec5b04c0a6bb8beb654b99">KTfwd::singlepop_gamete_t</a> = typedef <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>,<a class="el" href="../../da/d8b/namespaceKTfwd.html#a4ae4c7f1ef9dd1bd058811d3e2a69914">singlepop_mlist_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55b9cc59d4daf5acf3e25d92e5c9b253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a55b9cc59d4daf5acf3e25d92e5c9b253">KTfwd::singlepop_glist_t</a> = typedef std::list&lt;<a class="el" href="../../da/d8b/namespaceKTfwd.html#a08e0deaaa7ec5b04c0a6bb8beb654b99">singlepop_gamete_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;, std::allocator&lt;<a class="el" href="../../da/d8b/namespaceKTfwd.html#a08e0deaaa7ec5b04c0a6bb8beb654b99">singlepop_gamete_t</a>&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ae4c7f1ef9dd1bd058811d3e2a69914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d8b/namespaceKTfwd.html#a4ae4c7f1ef9dd1bd058811d3e2a69914">KTfwd::singlepop_mlist_t</a> = typedef std::list&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>,std::allocator&lt;<a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a4bf33686d51ed468e9bae483e741965a">mtype</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af72f8145754db271c7c696293de00ee9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::adjust_mutation_counts </td>
          <td>(</td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used internally </p>
<dl class="section note"><dt>Note</dt><dd>Will need a specialization if types have other data that need updating </dd></dl>

</div>
</div>
<a class="anchor" id="a728e20cb60f82b818b5cc570722079a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool KTfwd::check_sum </td>
          <td>(</td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d78/bneck_selection_ind_8cc-example.html#a5">bneck_selection_ind.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a5">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../dc/dc7/diploid_fixed_sh_ind_lambda_8cc-example.html#a5">diploid_fixed_sh_ind_lambda.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a12">diploid_ind.cc</a>, and <a class="el" href="../../d3/d70/diploid_ind_2locus_8cc-example.html#a12">diploid_ind_2locus.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3a49997b8e11c148177adea58dd916a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool KTfwd::check_sum </td>
          <td>(</td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise. </p>

</div>
</div>
<a class="anchor" id="af05d39195307329f16205963a265b41f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_allocator_type , typename mutation_type , typename list_allocator_type , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::init_with_ms </td>
          <td>(</td>
          <td class="paramtype">Sequence::SimData &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_allocator_type &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_allocator_type &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>max_chroms</em> = <code>std::numeric_limits&lt;unsigned&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a population with results from a coalescent simulation Takes an object of type Sequence::SimData from libsequence and initialized a population. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>A Sequence::SimData object </td></tr>
    <tr><td class="paramname">gametes</td><td>Destination for gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for mutations </td></tr>
    <tr><td class="paramname">max_chroms</td><td>The max number of gametes to read from d. Default is std::numeric_limits&lt;unsigned&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: It can be problematic using the ouptut from simulators that write to ASCI (plain text) files. If mutation positions are on the interval [0,1), then rounding during write will often truncate such that the data look like there are two mutations at the same site. This function attempts to control that in the following way: If three mutations in the file are at positions A, A, and B, then the positions are converted to ,A, A + (B-A)/2, and B. </dd></dl>

</div>
</div>
<a class="anchor" id="ac06ca8dade5d8e9af09e117e403bf644"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_at_end </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>A common use of this policy will be when a mutation model always gives rise to a gamete that does not currently exist in the population, such as the infinitely-many sites model of mutations. For such models, it is sufficient to simply append the new gamete to the existing vector.</p>
<p>Note: it is silly to pass ng to this function with ng.n = 0. </p>

</div>
</div>
<a class="anchor" id="a1c9791ec9905f663089b0a52d4facb0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_if_not_found </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afb2fd01e4b5a2bdcadb5e7c4382bb4d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_if_not_found </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a851c5d5579cbb54c0f0dffdf57e0d9b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_type::iterator KTfwd::insert_mutation_at_end </td>
          <td>(</td>
          <td class="paramtype">mutation_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type *&#160;</td>
          <td class="paramname"><em>mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion policy for a mutation. </p>
<p>Simply appends it to end of list_type mutations</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8be41eec381fecf3eb936bb1f7ef19af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_new_or_fail </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>If t is not found in ct, then insert t at end of ct, else return ct-&gt;end() </p>

</div>
</div>
<a class="anchor" id="ad884f819fe299dbf52d65253e21c1d17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_type::iterator KTfwd::insert_unique_or_fail </td>
          <td>(</td>
          <td class="paramtype">mutation_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type *&#160;</td>
          <td class="paramname"><em>mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a949b79d4df5bc10c6c1b31d311e4a392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename mutation_model , typename mutation_insertion_policy , typename gamete_insertion_policy , typename list_type_allocator , typename list_type_allocator2 , template&lt; typename, typename &gt; class list_type, template&lt; typename, typename &gt; class list_type2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator_type KTfwd::mutate_gamete </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type2&lt; typename iterator_type::value_type::mutation_type, list_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply mutation model to an individual gamete. Used for individual-based forward simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">gametes</td><td>Pointer to the list of gametes in the population </td></tr>
    <tr><td class="paramname">mutations</td><td>Pointer to the list of mutations in the population </td></tr>
    <tr><td class="paramname">g</td><td>An iterator to the gamete that will be mutated by this function </td></tr>
    <tr><td class="paramname">mu</td><td>the TOTAL mutation rate per gamete </td></tr>
    <tr><td class="paramname">mmodel</td><td>Mutation model policy </td></tr>
    <tr><td class="paramname">gpolicy</td><td>Policy determining how new gametes are added to population </td></tr>
    <tr><td class="paramname">mpolicy</td><td>Policy determining how new mutations are added to the population</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>g is passed non-const and will be modified by mutation events. </dd>
<dd>
The type of g is vector_type&lt;gamete_type,vector_type_allocator &gt;::iterator </dd>
<dd>
Used in invididual-based forward simulations. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the newly-created gamete, or to g if no mutation occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b4ac5932b4c1d311486946b2b6f612c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; KTfwd::population_sfs </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a258eb02c9748d27f8793e431c999feea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::push_at_end </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy Works via push_back instead of insert, so there is no return value. </p>
<p>A common use of this policy will be when a mutation model always gives rise to a gamete that does not currently exist in the population, such as the infinitely-many sites model of mutations. For such models, it is sufficient to simply append the new gamete to the existing vector.</p>
<p>Note: it is silly to pass ng to this function with ng.n = 0.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a3be2b56dc9917b88ed0a91ce7a3c6bb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type , typename istreamtype , typename diploid_reader_t  = diploidIOplaceholder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_reader_t &amp;&#160;</td>
          <td class="paramname"><em>dr</em> = <code>diploid_reader_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the metapopulation back from a binary-format file for individual-based simulations Read the metapopulation back from a binary-format file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metapop</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>Destination for the diploids </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">in</td><td>Input stream. Must either support .read() in a manner similar to std::istream types or be a gzFile from zlib. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a20">migsel_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af5ddb3ab8a5d762b4feda87205ad2253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_reader_type , typename istreamtype , typename diploid_reader_t  = diploidIOplaceholder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_pop </td>
          <td>(</td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_reader_t &amp;&#160;</td>
          <td class="paramname"><em>dr</em> = <code>diploid_reader_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the population back from a binary-format file for individual-based simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>Destination for the diploids </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">in</td><td>Input stream. Must either support .read() in a manner similar to std::istream types or be a gzFile from zlib. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a15">diploid_binaryIO_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af1ea92a126bcb9616e9c6a0207760774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mlocus_vector_type_allocator , template&lt; typename, typename &gt; class mlocus_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type , typename istreamtype , typename diploid_reader_t  = diploidIOplaceholder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_pop </td>
          <td>(</td>
          <td class="paramtype">mlocus_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, mlocus_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mlocus_gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_reader_t &amp;&#160;</td>
          <td class="paramname"><em>dr</em> = <code>diploid_reader_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the population back from a binary-format file for individual-based multilocus simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mlocus_gametes</td><td>A container of gametes for a multilocus simulation </td></tr>
    <tr><td class="paramname">mutations</td><td>A linked list of mutation objects </td></tr>
    <tr><td class="paramname">diploids</td><td>A container of individuals in the simulation </td></tr>
    <tr><td class="paramname">mr</td><td>A function object taking a input stream as argument, and reads a mutation object from the stream. Must be provided by the library user. </td></tr>
    <tr><td class="paramname">in</td><td>An object whose public interface is compatible with std::ostream or is a gzFile. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a46b107991548a40821e132496c1693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename recombination_map , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned KTfwd::recombine_gametes </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>littler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_map &amp;&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recombination for individual-based forward simulations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">littler</td><td>The probability of a single recombination event between g1 and g2 </td></tr>
    <tr><td class="paramname">gametes</td><td>Pointer to the list of gametes in the population </td></tr>
    <tr><td class="paramname">g1</td><td>Iterator to the first gamete involved in the recombination event </td></tr>
    <tr><td class="paramname">g2</td><td>Iterator to the second gamete involved in the recombination event </td></tr>
    <tr><td class="paramname">mf</td><td>Recombination policy which generates crossover positions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>g1 and g2 will be changed </dd>
<dd>
The type of g1 and g2 is gamete_list_type&lt;gamete_type,list_type_allocator &gt;::iterator </dd>
<dd>
The return value may be 0 even if littler is large. The code recognizes when crossovers could not modify the gametes, and the function returns when such cases are found </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossovers that happened between g1 and g2 (which is Poisson with mean littler) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dc/dc7/diploid_fixed_sh_ind_lambda_8cc-example.html#a9">diploid_fixed_sh_ind_lambda.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad758ef2a67e1fbb768640e533377f506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename list_type_allocator , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned KTfwd::recombine_gametes </td>
          <td>(</td>
          <td class="paramtype">const vector_type&lt; double, vector_type_allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload for fixed xover positions. Typically, this is called by the version taking a recombination policy as an argument.</p>
<p>If you wish to call this version directly, only do so if length pos &gt; 1, pos is sorted in ascending order, and the last value in pos is std::numeric_limits&lt;double&gt;::max(), which is assumed to be a terminating value larger than any possible value for a mutation's position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>A vector (with interface of std::vector) containing recombination breakpoints. See note below. </td></tr>
    <tr><td class="paramname">gametes</td><td>A container of the gametes segregating in the population </td></tr>
    <tr><td class="paramname">g1</td><td>An iterator, derived from gametes, representing one parental gamete. </td></tr>
    <tr><td class="paramname">g2</td><td>An iterator, derived from gametes, representing the other parental gamete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of breakpoints, which equals pos.size() - 1, as that is fixed in this case. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vector pos must be sorted (ascending order) and must contain the value std::numeric_limits&lt;double&gt;::max() as a terminating value. </dd></dl>

</div>
</div>
<a class="anchor" id="a84e666ea27d38bdfc539ffd23653eaa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_fixed_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; mutation_type, vector_type_allocator1 &gt; *&#160;</td>
          <td class="paramname"><em>fixations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; unsigned, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>fixation_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove mutations from population Removes mutations that are fixed or lost. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d78/bneck_selection_ind_8cc-example.html#a11">bneck_selection_ind.cc</a>, <a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a12">diploid_binaryIO_ind.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a11">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../dc/dc7/diploid_fixed_sh_ind_lambda_8cc-example.html#a12">diploid_fixed_sh_ind_lambda.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a11">diploid_ind.cc</a>, <a class="el" href="../../d3/d70/diploid_ind_2locus_8cc-example.html#a13">diploid_ind_2locus.cc</a>, and <a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a16">migsel_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adbc0bd4b96e6164ec339823c85de235e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_fixed_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; mutation_type, vector_type_allocator1 &gt; *&#160;</td>
          <td class="paramname"><em>fixations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; unsigned, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>fixation_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_lookup_table *&#160;</td>
          <td class="paramname"><em>lookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove mutations from population Removes mutations that are fixed or lost. </p>
<dl class="section note"><dt>Note</dt><dd>: lookup must be compatible with lookup-&gt;erase(lookup-&gt;find(double)) </dd></dl>

</div>
</div>
<a class="anchor" id="a86a4fcecb15c101816ccdd15eefd6a1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove mutations from population Removes mutations that are lost. </p>

</div>
</div>
<a class="anchor" id="ad73eeda26047df89b8ea303c0d8a6b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_lookup_table *&#160;</td>
          <td class="paramname"><em>lookup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove mutations from population Removes mutations that are lost. </p>
<dl class="section note"><dt>Note</dt><dd>: lookup must be compatible with lookup-&gt;erase(lookup-&gt;find(double)) </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b321ba63144739f7a25675da26bf02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , typename bw_locus_rec_fxn , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; locus_vector_type&lt; diploid_geno_t, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model_container &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy_container &amp;&#160;</td>
          <td class="paramname"><em>rec_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>r_between_loci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bw_locus_rec_fxn &amp;&#160;</td>
          <td class="paramname"><em>blrf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single deme, multilocus model, changing population size. </p>

</div>
</div>
<a class="anchor" id="a18df6351fa3148914bbb844c36bc3e05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d78/bneck_selection_ind_8cc-example.html#a6">bneck_selection_ind.cc</a>, <a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a7">diploid_binaryIO_ind.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a6">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../dc/dc7/diploid_fixed_sh_ind_lambda_8cc-example.html#a6">diploid_fixed_sh_ind_lambda.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a6">diploid_ind.cc</a>, <a class="el" href="../../d3/d70/diploid_ind_2locus_8cc-example.html#a10">diploid_ind_2locus.cc</a>, and <a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a12">migsel_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afe562b17f78f17b16d477ae93a5c2eb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , typename bw_locus_rec_fxn , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; locus_vector_type&lt; diploid_geno_t, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model_container &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy_container &amp;&#160;</td>
          <td class="paramname"><em>rec_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>r_between_loci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bw_locus_rec_fxn &amp;&#160;</td>
          <td class="paramname"><em>blrf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37bfd39cb9e480156946dc9969bde8e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a44bc3d0dbb6b092f56ba18331751af77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metapop_diploid_vector_type&lt; diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const migration_policy &amp;&#160;</td>
          <td class="paramname"><em>mig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>f</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad592697866c4bacdf00ccb6e902c0891"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_geno_t , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metapop_diploid_vector_type&lt; diploid_vector_type&lt; diploid_geno_t, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>N_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const migration_policy &amp;&#160;</td>
          <td class="paramname"><em>mig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>f</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evolve a metapopulation where demes may be changing size. For individual-based sims. Evolve a metapopulation where demes may be changing size. For individual-based sims. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">metapop</td><td>Pointer to vector of lists of gametes. </td></tr>
    <tr><td class="paramname">diploids</td><td>Pointer to the vector of vectors of parents from which we sample offspring </td></tr>
    <tr><td class="paramname">mutations</td><td>Pointer to list of mutations currently in population </td></tr>
    <tr><td class="paramname">N_curr</td><td>The current population sizes. There must be diploids-&gt;size() values in this array </td></tr>
    <tr><td class="paramname">N_next</td><td>The population sizes in the daughter generation. There must be diploids-&gt;size() values in this array </td></tr>
    <tr><td class="paramname">mu</td><td>The total mutation rate per gamete </td></tr>
    <tr><td class="paramname">mmodel</td><td>Mutation model policy </td></tr>
    <tr><td class="paramname">rec_pol</td><td>Recombination model policy </td></tr>
    <tr><td class="paramname">mpolicy</td><td>Policy determining how new mutations are added to the population </td></tr>
    <tr><td class="paramname">gpolicy_mut</td><td>Policy determining how new gametes are added to population after a mutation event </td></tr>
    <tr><td class="paramname">ffs</td><td>Container of fitness functions. One for each deme. </td></tr>
    <tr><td class="paramname">mp</td><td>Policy determining how to remove mutations from a diploid (e.g., removing fixed and/or lost mutations) </td></tr>
    <tr><td class="paramname">mig</td><td>Migration policy. This function/function object must take a single size_t (values 0 to metapop-&gt;size()-1). If no migration event occurs, the passed value is returned. Otherwise, a size_t representing the index of the deme from which the other parent comes (aka the migrant) is returned. </td></tr>
    <tr><td class="paramname">f</td><td>Probability that a mating is a selfing event. This is an array, with 1 f per deme.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>diploids will be updated to reflect the new diploid genotypes post-sampling (the descedants). Gametes will be changed by mutation, recombination, and sampling. Mutations will be changed by mutation and sampling. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mean fitness of the parental generation </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9d58d1446e2d4a5aae1e5c4e7ba946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename allocator_t , template&lt; typename, typename &gt; class container_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; KTfwd::sample_sfs </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_t&lt; gamete_type, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a105a292a1e5c591d64d14caf4062e2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename fitness_updating_policy_hom , typename fitness_updating_policy_het &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::site_dependent_fitness2 </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fitness_updating_policy_hom &amp;&#160;</td>
          <td class="paramname"><em>fpol_hom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fitness_updating_policy_het &amp;&#160;</td>
          <td class="paramname"><em>fpol_het</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>starting_fitness</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a91ac7525d84cfec32e3007029da92cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::uncheck </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f6270abe1bf379c5458a3d09bc99455"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::update_if_exists_insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>Useful when mutation models can give rise to gametes identical to those currently existing in the population. This will happen under finite-sites models.</p>
<p>If the new gamete (ng) is not found in gametes, then it is inserted at the end.</p>
<p>Otherwise, if it is found, the count of that gamete in the population is inremented by ng.n (the count of new gamete). </p>

</div>
</div>
<a class="anchor" id="a4f12d7c4af0b0d5b6dc48772d1cae49d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::update_if_exists_push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>Useful when mutation models can give rise to gametes identical to those currently existing in the population. This will happen under finite-sites models.</p>
<p>If the new gamete (ng) is not found in gametes, then it is inserted at the end.</p>
<p>Otherwise, if it is found, the count of that gamete in the population is inremented by ng.n (the count of new gamete).</p>
<p>Note: it is silly to pass ng to this function with ng.n = 0. </p>

</div>
</div>
<a class="anchor" id="ab62f60cccc4f91b8d9695a4d9abf300a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_writer_type , typename ostreamtype , typename diploid_writer_t  = diploidIOplaceholder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">const gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer_type &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_writer_t &amp;&#160;</td>
          <td class="paramname"><em>dw</em> = <code>diploid_writer_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a18">migsel_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4826160f7e99b8c2cdb7fa2769c6aeeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_writer_type , typename ostreamtype , typename diploid_writer_t  = diploidIOplaceholder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_pop </td>
          <td>(</td>
          <td class="paramtype">const gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer_type &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_writer_t &amp;&#160;</td>
          <td class="paramname"><em>dw</em> = <code>diploid_writer_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write population to binary-format file for individual-based simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>The vector of lists gametes for each deme in metapop </td></tr>
    <tr><td class="paramname">mutations</td><td>The list of mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>The vector of diploids </td></tr>
    <tr><td class="paramname">mw</td><td>A function object taking a mutation and an ostreamtype as arguments. Must be provided by the library user. </td></tr>
    <tr><td class="paramname">buffer</td><td>An ouptut stream into which the population is written. This is the "return value" of the function. The stream must support a write() function akin to those found in the std::ostream classes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If is often useful for buffer to be of type std::ostringstream to allow writing of the buffered data to C-style file handles/pointers, in turn allowing file locking which speeds up performance on distributed file systems. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a13">diploid_binaryIO_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a155a4a3be11d90ac32a75618ccf24a8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename diploid_geno_t , typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mlocus_vector_type_allocator , template&lt; typename, typename &gt; class mlocus_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_writer_type , typename ostreamtype , typename diploid_writer_t  = diploidIOplaceholder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_pop </td>
          <td>(</td>
          <td class="paramtype">const mlocus_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, mlocus_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mlocus_gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_vv_type&lt; diploid_vector_type&lt; diploid_geno_t, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer_type &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_writer_t &amp;&#160;</td>
          <td class="paramname"><em>dw</em> = <code>diploid_writer_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the population to a binary-format file for individual-based multilocus simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mlocus_gametes</td><td>A container of gametes for a multilocus simulation </td></tr>
    <tr><td class="paramname">mutations</td><td>A linked list of mutation objects </td></tr>
    <tr><td class="paramname">diploids</td><td>A container of individuals in the simulation </td></tr>
    <tr><td class="paramname">mw</td><td>A function object taking a mutation and an ostreamtype as arguments. Must be provided by the library user. </td></tr>
    <tr><td class="paramname">buffer</td><td>An object whose public interface is compatible with std::ostream or is a gzFile </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
