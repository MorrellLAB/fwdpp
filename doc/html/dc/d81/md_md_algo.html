<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: Algorithmic details of recombination</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.3.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Algorithmic details of recombination </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>(This document first appeared in <b>fwdpp</b> 0.3.3.)</p>
<p>The release of <b>fwdpp</b> 0.3.3 contained two significant improvements in the scalability of the code for large simulations.</p>
<h2>Simplifying crossing-over</h2>
<p>Through <b>fwdpp</b> 0.3.2, the algorithm for crosssing over went like this:</p>
<ul>
<li>Take the two gametes in a parent</li>
<li>Recombine them at a set of breakpoints determined by the user-defined policy</li>
<li>Randomly-pick one of the two recombinant gametes to pass on to the offspring.</li>
</ul>
<p>In "pictures", the algorithm went like:</p>
<ul>
<li>Starting with parental gametes: AAAAAA and BBBBBB</li>
<li>Ending with recombinant gametes: AAABBB and BBBAAAA</li>
<li>Pick one to pass on (say, AAABBB), and discard the other)</li>
</ul>
<p>On obvious problem with this approach is that we are creating a gamete that we don't do anything with: the one that doesn't get passed on simply gets discarded, and is thus a waste of all the copying (of pointers to mutations) that it took to create that gamete.</p>
<p>Version 0.3.3 of the library introduced the following change (which I honestly wish I'd thought of several years ago...):</p>
<ul>
<li>Take the two gametes in a parent, pg1 and pg2</li>
<li>Randomly pick one to be the descendant. If it is pg2, swap the pointers to pg1 and pg2.</li>
<li>Create a single recombinant and assign the appropriate pointer as the new value of pg1</li>
</ul>
<p>In "pictures":</p>
<ul>
<li>Starting with parental gametes: pg1 = AAAAAA and pg2 = BBBBBB</li>
<li>Half the time, swap pg1 and pg2</li>
<li>Generate a single recombinant, either AAABBB <em>or</em> BBBAAA</li>
</ul>
<p>What are the consequences of this new method? Let's start with the good:</p>
<ul>
<li>Reduced run-time. I <em>think</em> the benefit is typically 15-20%, but this change was not "good science", as I also changed how memory for storing recombinant gametes was allocated (see next subsection).</li>
</ul>
<p>And now, the bad:</p>
<ul>
<li>For a given random number seed, the output is different for programs compiled using 0.3.2 and 0.3.3. This is because the "Mendel" step occurs earlier in 0.3.3, thus changing the context of all subsequent calls to the random number generator.</li>
</ul>
<h3>Changing memory allocation patterns</h3>
<p>Through <b>fwdpp</b> 0.3.2, the library would allocate memory for the two recombinant gametes. This occurred for every recombination event, meaning that for <img class="formulaInl" alt="$\rho = 4Nr$" src="../../form_65.png"/>, the expected number of containers created each generation was <img class="formulaInl" alt="$4\rho$" src="../../form_66.png"/>, as there are <img class="formulaInl" alt="$4Nr$" src="../../form_67.png"/> expected recombination events each generation (2 parents per 2N offspring, each parent recombining at <img class="formulaInl" alt="$r$" src="../../form_28.png"/> positions on average), and 4 containers needed per recombining parent (because pointers to neutral and selected mutations are stored separately).</p>
<p>The method describe above worked ok, but ultimately results in a massive number of calls for new memory over the course of a simulation.</p>
<p>In 0.3.3, we can cut the number of allocations in half because we generate half as many recombinant chromosomes (see above). However, the library takes the following steps to reduce allocations even further:</p>
<ul>
<li>Programs must now manage the allocation of the two vectors required to store a recombinant. Let's call them "neutral" and "selected".</li>
<li>They are declared in <a class="el" href="../../d8/d48/bneck__selection__dist_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and the programmer should use "reserve" to pre-allocate some memory for them.</li>
<li>These containers are passed into recombination policies and emptied/filled as required.</li>
</ul>
<p>The positives of the new approach are:</p>
<ul>
<li>Reduced memory use. We can now just let the vector class adjust its capacity as needed, and grow as needed during the simulation, resulting in many fewer requests for memory.</li>
<li>In combo with the new crossing-over method (see above), run times are reduced.</li>
</ul>
<p>The negative:</p>
<ul>
<li>Passing these containers to recombination policies represents an API change.</li>
</ul>
<h2>Checking that a recombinant gamete is unique</h2>
<p><b>fwdpp</b> uses doubly-linked lists for storing pointers (iterators) to mutations and gametes. The advantage of these lists is that pointers remain valid after insertion/deletion to/from lists. (This is in contrast to the case with a vector/array, where insertion/removal triggers a reallocation, which often moves memory, resulting in "pointer/iterator invalidation".) The down-side of lists is that moving through them is relatively expensive. They fragment memory over time because they use discontinuous storage, and therefore searching through them is expensive.</p>
<p>One of the goals of the library is to store objects once and only once. Thus, after a recombination, we need to do the following:</p>
<ul>
<li>Ask if the recombinant gamete is unique.</li>
<li>If not, we simply assign the pointer to the recombinant as the pointer to the version that we already have in a list</li>
<li>If so, we insert the new gamete at the end of the list, and store a pointer to it.</li>
</ul>
<p>Through <b>fwdpp</b> 0.3.2, the library searched the entire gamete list to see if the recombinant already exists. This search took <img class="formulaInl" alt="$O(g)$" src="../../form_68.png"/> operations, where <img class="formulaInl" alt="$g$" src="../../form_59.png"/> is the number of unique gametes in the population. Such linear searches are slow for linked lists and scale terribly with increasing population size and/or mutation and/or recombination rate.</p>
<p>In 0.3.3, the linear searches are replaced with <img class="formulaInl" alt="$O(log(g))$" src="../../form_69.png"/> lookups via a lookup table that is calculated internally every generation.</p>
<p>The lookup table associates the total number of mutations in a gamete (neutral + selected mutations) and the iterator to that gamete in the linked list. Given a new gamete, we can find the <em>range</em> of gametes in the lookup table with the same total number of mutations in logarithmic time. If the size of that range is zero, then the new gamete is by definition unique, and we insert it. Otherwise, we must compare the recombinant to all gamtes in the range, which is a linear serach, but this time over a much smaller range than what <b>fwdpp</b> 0.3.2 was doing.</p>
<p>The plus sides:</p>
<ul>
<li>Massive improvements in the scalability of the simulation. For the cost of building the lookup table, we replace <img class="formulaInl" alt="$O(\rho/2)$" src="../../form_70.png"/> linear searches of a linked list with <img class="formulaInl" alt="$O(\rho/2)$" src="../../form_70.png"/> logarithmic-time lookups. Further, <em>we rarely have to do the secondary linear search!</em></li>
</ul>
<p>The down side (quibble):</p>
<ul>
<li>We must pass the lookup table on to the recombination policy, and thus we need an API change. However, we've already changed the API in 0.3.3 because of the changes to how recombination works, so this is a very nit-picking down-side.</li>
</ul>
<h3>Details on the lookup table</h3>
<p>(This section exists in hope that KRT reads it before trying to reinvent the wheel in the future. Fat chance of that...)</p>
<p>During testing, I tried the following schemes for the lookup tables:</p>
<ul>
<li>std::vector&lt; std::pair&lt;std::int32_t, glist::iterator&gt; &gt;, sorted using either std::stable_sort or std::sort.</li>
<li>std::multimap&lt; std::int32_t, glist::iterator &gt;</li>
<li>std::unordered_multimap&lt; std::int32_t, glist::iterator &gt;</li>
</ul>
<p>I benchmarked each approach with the following command line:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#Keep seed the same for all three...</span></div>
<div class="line"><span class="preprocessor">diploid_ind 10000 4000 4000 100000 10 1 SEED</span></div>
</div><!-- fragment --><p>All three lookup tables had very similar run-times and peak RAM use. However, (my implementation using) the unordered_multimap resulted in simulations with incorrect distributions of summary statistics.</p>
<p>The library currently defaults to using the std::multimap. Programs may be compiled using "sorted vector of pairs" approach by passing -DFWDPP_VECTOR_GLOOKUP to the compiler/preprocessor. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
