<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>fwdpp: Syntactic sugar layer</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Syntactic sugar layer</div>  </div>
</div><!--header-->
<div class="contents">

<p>Syntactic sugar for easier development of simulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:da/dd8/GSLrng__t_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dd8/GSLrng__t_8hpp.html">GSLrng_t.hpp</a></td></tr>
<tr class="memdesc:da/dd8/GSLrng__t_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for gsl_rng *. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dde/structKTfwd_1_1generalmut.html">KTfwd::generalmut&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation type allowing arbitray number of "s,h" pairs representing effect sizes,dominance.This type represents a mutation with a number of 's' and 'h' parameters that are fixed at compile time.  <a href="../../da/dde/structKTfwd_1_1generalmut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9e/structKTfwd_1_1generalmut__vec.html">KTfwd::generalmut_vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation type allowing arbitray number of "s,h" pairs representing effect sizes,dominance.This type represents a mutation with a number of 's' and 'h' parameters that are determined at run time.  <a href="../../d9/d9e/structKTfwd_1_1generalmut__vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d07/structKTfwd_1_1infsites.html">KTfwd::infsites</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function object implementing the infinitely-many sites mutation model for "standard" population-genetic scenarios.  <a href="../../df/d07/structKTfwd_1_1infsites.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/classKTfwd_1_1sugar_1_1popbase.html">KTfwd::sugar::popbase&lt; mutation_type, mcont, gcont, dipvector, mvector, ftvector, lookup_table_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for population objects.  <a href="../../d7/d94/classKTfwd_1_1sugar_1_1popbase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/structKTfwd_1_1popgenmut.html">KTfwd::popgenmut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutations with selection, dominance, and tracking age of origin The "standard" mutation type for population genetic simulation. A mutation has its own selection and dominance coefficients.  <a href="../../dc/dcc/structKTfwd_1_1popgenmut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d25/structKTfwd_1_1mutation__writer.html">KTfwd::mutation_writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates serialization of mutation types supported by the fwdpp sugar library.  <a href="../../de/d25/structKTfwd_1_1mutation__writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1a/structKTfwd_1_1mutation__reader.html">KTfwd::mutation_reader&lt; mutation_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates serialization of mutation types supported by the fwdpp sugar library.  <a href="../../d7/d1a/structKTfwd_1_1mutation__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8e/structKTfwd_1_1serialize.html">KTfwd::serialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize populations.  <a href="../../d0/d8e/structKTfwd_1_1serialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dde/structKTfwd_1_1deserialize.html">KTfwd::deserialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize population objects.  <a href="../../d6/dde/structKTfwd_1_1deserialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d99/structKTfwd_1_1sugar_1_1gsl__rng__deleter.html">KTfwd::sugar::gsl_rng_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to delete a gsl_rng *.  <a href="../../d5/d99/structKTfwd_1_1sugar_1_1gsl__rng__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d43/structKTfwd_1_1sugar_1_1GSL__RNG__TYPE__TAG.html">KTfwd::sugar::GSL_RNG_TYPE_TAG&lt; GSL_RNG_TYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch tag for gsl_rng * types.  <a href="../../d7/d43/structKTfwd_1_1sugar_1_1GSL__RNG__TYPE__TAG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2b/structKTfwd_1_1sugar_1_1FWDPP__SUGAR__POPTAG.html">KTfwd::sugar::FWDPP_SUGAR_POPTAG&lt; FWDPP_SUGAR_POPTYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch tag template for population types supported by sugar layer.  <a href="../../d9/d2b/structKTfwd_1_1sugar_1_1FWDPP__SUGAR__POPTAG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d74/classKTfwd_1_1sugar_1_1singlepop.html">KTfwd::sugar::singlepop&lt; mutation_type, mcont, gcont, dipvector, mvector, ftvector, lookup_table_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction of what is needed to simulate a single population using an individual-based sampler from fwdpp.  <a href="../../d5/d74/classKTfwd_1_1sugar_1_1singlepop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de0/classKTfwd_1_1sugar_1_1metapop.html">KTfwd::sugar::metapop&lt; mutation_type, mcont, gcont, dipvector, vdipvector, mvector, ftvector, lookup_table_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction of what is needed to simulate a metapopulation using an individual-based sampler from fwdpp.  <a href="../../d3/de0/classKTfwd_1_1sugar_1_1metapop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d11/structKTfwd_1_1sugar_1_1multiloc.html">KTfwd::sugar::multiloc&lt; mutation_type, mcont, gcont, dipvector, mvector, ftvector, lookup_table_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction of what is needed to simulate a multilocus simulation using an individual-based sampler from fwdpp.  <a href="../../d3/d11/structKTfwd_1_1sugar_1_1multiloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf66ce861e458d7e15f98bbbb9e87ad38"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename diploid_t  = std::pair&lt;std::size_t,std::size_t&gt;&gt; </td></tr>
<tr class="memitem:gaf66ce861e458d7e15f98bbbb9e87ad38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gaf66ce861e458d7e15f98bbbb9e87ad38">KTfwd::metapop</a> = sugar::metapop&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>, std::vector&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a> &gt;, std::vector&lt; gamete &gt;, std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt; &gt;, std::vector&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a> &gt;, std::vector&lt; uint_t &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;&gt;</td></tr>
<tr class="memdesc:gaf66ce861e458d7e15f98bbbb9e87ad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single locus metapopulation simulation object.  <a href="#gaf66ce861e458d7e15f98bbbb9e87ad38">More...</a><br /></td></tr>
<tr class="separator:gaf66ce861e458d7e15f98bbbb9e87ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5993990a90021e4eeb4170bde943ff54"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename diploid_t  = std::pair&lt;std::size_t,std::size_t&gt;&gt; </td></tr>
<tr class="memitem:ga5993990a90021e4eeb4170bde943ff54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga5993990a90021e4eeb4170bde943ff54">KTfwd::multiloc</a> = sugar::multiloc&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>, std::vector&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a> &gt;, std::vector&lt; gamete &gt;, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;&gt;, std::vector&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a> &gt;, std::vector&lt; uint_t &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt;&gt;</td></tr>
<tr class="memdesc:ga5993990a90021e4eeb4170bde943ff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single population, multilocus simulation. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc.  <a href="#ga5993990a90021e4eeb4170bde943ff54">More...</a><br /></td></tr>
<tr class="separator:ga5993990a90021e4eeb4170bde943ff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618c1f80e050a17d765e89f784f6abdb"><td class="memTemplParams" colspan="2">template&lt;typename mtype , typename diploid_t  = std::pair&lt;std::size_t,std::size_t&gt;&gt; </td></tr>
<tr class="memitem:ga618c1f80e050a17d765e89f784f6abdb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga618c1f80e050a17d765e89f784f6abdb">KTfwd::singlepop</a> = sugar::singlepop&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>, std::vector&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a> &gt;, std::vector&lt; gamete &gt;, std::vector&lt; <a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a> &gt;, std::vector&lt; <a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a> &gt;, std::vector&lt; uint_t &gt;, std::unordered_set&lt; double, std::hash&lt; double &gt;, <a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga618c1f80e050a17d765e89f784f6abdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single locus, single population object.  <a href="#ga618c1f80e050a17d765e89f784f6abdb">More...</a><br /></td></tr>
<tr class="separator:ga618c1f80e050a17d765e89f784f6abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa991ef48b5f7fd6f7ea7a289e8973cee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gaa991ef48b5f7fd6f7ea7a289e8973cee">KTfwd::sugar::gsl_rng_ptr_t</a> = std::unique_ptr&lt; gsl_rng, gsl_rng_deleter &gt;</td></tr>
<tr class="memdesc:gaa991ef48b5f7fd6f7ea7a289e8973cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer wrapper to gsl_rng *.  <a href="#gaa991ef48b5f7fd6f7ea7a289e8973cee">More...</a><br /></td></tr>
<tr class="separator:gaa991ef48b5f7fd6f7ea7a289e8973cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1b3a08c798b89fea7c36a7180d8a0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga1d1b3a08c798b89fea7c36a7180d8a0b">KTfwd::sugar::SINGLEPOP_TAG</a> = FWDPP_SUGAR_POPTAG&lt; FWDPP_SUGAR_POPTYPE::SINGLE &gt;</td></tr>
<tr class="memdesc:ga1d1b3a08c798b89fea7c36a7180d8a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-population simulations.  <a href="#ga1d1b3a08c798b89fea7c36a7180d8a0b">More...</a><br /></td></tr>
<tr class="separator:ga1d1b3a08c798b89fea7c36a7180d8a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec01f9f2a41e638a492780fdddb3048"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga8ec01f9f2a41e638a492780fdddb3048">KTfwd::sugar::METAPOP_TAG</a> = FWDPP_SUGAR_POPTAG&lt; FWDPP_SUGAR_POPTYPE::META &gt;</td></tr>
<tr class="memdesc:ga8ec01f9f2a41e638a492780fdddb3048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-population simulations.  <a href="#ga8ec01f9f2a41e638a492780fdddb3048">More...</a><br /></td></tr>
<tr class="separator:ga8ec01f9f2a41e638a492780fdddb3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf921d18379b491101cec5291b2e08432"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gaf921d18379b491101cec5291b2e08432">KTfwd::sugar::MULTILOCPOP_TAG</a> = FWDPP_SUGAR_POPTAG&lt; FWDPP_SUGAR_POPTYPE::MULTILOC &gt;</td></tr>
<tr class="memdesc:gaf921d18379b491101cec5291b2e08432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-population, multi-locus simulations.  <a href="#gaf921d18379b491101cec5291b2e08432">More...</a><br /></td></tr>
<tr class="separator:gaf921d18379b491101cec5291b2e08432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga04107baa95fa1f3b160d7618d3369d75"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga04107baa95fa1f3b160d7618d3369d75">KTfwd::sugar::GSL_RNG_TYPE</a> { <a class="el" href="../../de/d6e/group__sugar.html#gga04107baa95fa1f3b160d7618d3369d75a9628b10562b643bff5d84e6dbf17d866">KTfwd::sugar::GSL_RNG_TYPE::MT19937</a>, 
<a class="el" href="../../de/d6e/group__sugar.html#gga04107baa95fa1f3b160d7618d3369d75a1c61b3e6e6203fecfb58277795ad23e0">KTfwd::sugar::GSL_RNG_TYPE::TAUS2</a>
 }</td></tr>
<tr class="memdesc:ga04107baa95fa1f3b160d7618d3369d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">gsl_rng * types supported by fwdpp's sugar layer  <a href="../../de/d6e/group__sugar.html#ga04107baa95fa1f3b160d7618d3369d75">More...</a><br /></td></tr>
<tr class="separator:ga04107baa95fa1f3b160d7618d3369d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6900fb51d7d4e8e89c6ce5f527eb3dad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga6900fb51d7d4e8e89c6ce5f527eb3dad">KTfwd::sugar::FWDPP_SUGAR_POPTYPE</a> { <a class="el" href="../../de/d6e/group__sugar.html#gga6900fb51d7d4e8e89c6ce5f527eb3dada0679273e201afd0bf57af3961f8a23b8">KTfwd::sugar::FWDPP_SUGAR_POPTYPE::SINGLE</a>, 
<a class="el" href="../../de/d6e/group__sugar.html#gga6900fb51d7d4e8e89c6ce5f527eb3dadae59f1c4fb1aa1d70a8c3eb59ff3e461b">KTfwd::sugar::FWDPP_SUGAR_POPTYPE::META</a>, 
<a class="el" href="../../de/d6e/group__sugar.html#gga6900fb51d7d4e8e89c6ce5f527eb3dadacb4eaa80f71ab986f42364e89d58684d">KTfwd::sugar::FWDPP_SUGAR_POPTYPE::MULTILOC</a>
 }</td></tr>
<tr class="memdesc:ga6900fb51d7d4e8e89c6ce5f527eb3dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of populations supported by sugar layer.  <a href="../../de/d6e/group__sugar.html#ga6900fb51d7d4e8e89c6ce5f527eb3dad">More...</a><br /></td></tr>
<tr class="separator:ga6900fb51d7d4e8e89c6ce5f527eb3dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga20e03e38a69ea6103541149318de36fa"><td class="memTemplParams" colspan="2">template&lt;typename mcont_t , typename mcounts_t &gt; </td></tr>
<tr class="memitem:ga20e03e38a69ea6103541149318de36fa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga20e03e38a69ea6103541149318de36fa">KTfwd::sugar::get_mut_index</a> (mcont_t &amp;mutations, mcounts_t &amp;mcounts, typename mcont_t::value_type &amp;new_mutation)</td></tr>
<tr class="memdesc:ga20e03e38a69ea6103541149318de36fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for implementing <a class="el" href="../../de/d6e/group__sugar.html#gabcf95af0822bbd57f0aa85408c026201" title="Add a mutation into a population at a given frequency. ">KTfwd::add_mutation</a>.  <a href="#ga20e03e38a69ea6103541149318de36fa">More...</a><br /></td></tr>
<tr class="separator:ga20e03e38a69ea6103541149318de36fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf95af0822bbd57f0aa85408c026201"><td class="memTemplParams" colspan="2">template&lt;typename poptype , class... Args&gt; </td></tr>
<tr class="memitem:gabcf95af0822bbd57f0aa85408c026201"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#gabcf95af0822bbd57f0aa85408c026201">KTfwd::add_mutation</a> (<a class="el" href="../../d5/da7/extensions_8cc.html#aa222338fad215f6f35c2f630479ddbf3">poptype</a> &amp;p, const std::vector&lt; std::size_t &gt; &amp;indlist, const std::vector&lt; short &gt; &amp;clist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gabcf95af0822bbd57f0aa85408c026201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a mutation into a population at a given frequency.  <a href="#gabcf95af0822bbd57f0aa85408c026201">More...</a><br /></td></tr>
<tr class="separator:gabcf95af0822bbd57f0aa85408c026201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114fed33dc72b0381c462de256f33f85"><td class="memTemplParams" colspan="2">template&lt;typename metapoptype , class... Args&gt; </td></tr>
<tr class="memitem:ga114fed33dc72b0381c462de256f33f85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga114fed33dc72b0381c462de256f33f85">KTfwd::add_mutation</a> (metapoptype &amp;p, const std::vector&lt; std::size_t &gt; demes, const std::vector&lt; std::vector&lt; std::size_t &gt;&gt; &amp;indlist, const std::vector&lt; std::vector&lt; short &gt;&gt; &amp;clist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga114fed33dc72b0381c462de256f33f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a mutation into a deme from a population at a given frequency in a specific set of demes.  <a href="#ga114fed33dc72b0381c462de256f33f85">More...</a><br /></td></tr>
<tr class="separator:ga114fed33dc72b0381c462de256f33f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8184c8c27beb420671af0546904661"><td class="memTemplParams" colspan="2">template&lt;typename multiloc_poptype , class... Args&gt; </td></tr>
<tr class="memitem:ga8c8184c8c27beb420671af0546904661"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga8c8184c8c27beb420671af0546904661">KTfwd::add_mutation</a> (multiloc_poptype &amp;p, const std::size_t locus, const std::vector&lt; std::size_t &gt; &amp;indlist, const std::vector&lt; short &gt; &amp;clist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga8c8184c8c27beb420671af0546904661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a mutation into a population at a given frequency at in a specific locus.  <a href="#ga8c8184c8c27beb420671af0546904661">More...</a><br /></td></tr>
<tr class="separator:ga8c8184c8c27beb420671af0546904661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c0af3daeea9be414949bedf525f160"><td class="memTemplParams" colspan="2">template&lt;typename poptype &gt; </td></tr>
<tr class="memitem:ga34c0af3daeea9be414949bedf525f160"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga34c0af3daeea9be414949bedf525f160">KTfwd::add_mutations</a> (<a class="el" href="../../d5/da7/extensions_8cc.html#aa222338fad215f6f35c2f630479ddbf3">poptype</a> &amp;p, const std::vector&lt; std::size_t &gt; &amp;indlist, const std::vector&lt; short &gt; &amp;clist, const std::vector&lt; std::size_t &gt; &amp;mutation_indexes)</td></tr>
<tr class="memdesc:ga34c0af3daeea9be414949bedf525f160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of mutations into a set of individuals in a population.  <a href="#ga34c0af3daeea9be414949bedf525f160">More...</a><br /></td></tr>
<tr class="separator:ga34c0af3daeea9be414949bedf525f160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ea507da5177570ea74a52bb071bcd2"><td class="memTemplParams" colspan="2">template&lt;typename metapoptype &gt; </td></tr>
<tr class="memitem:ga49ea507da5177570ea74a52bb071bcd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga49ea507da5177570ea74a52bb071bcd2">KTfwd::add_mutations</a> (metapoptype &amp;p, const std::vector&lt; std::size_t &gt; demes, const std::vector&lt; std::vector&lt; std::size_t &gt;&gt; &amp;indlist, const std::vector&lt; std::vector&lt; short &gt;&gt; &amp;clist, const std::vector&lt; std::size_t &gt; &amp;mutation_indexes)</td></tr>
<tr class="memdesc:ga49ea507da5177570ea74a52bb071bcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of mutation into a deme from a population at a given frequency in a specific set of demes.  <a href="#ga49ea507da5177570ea74a52bb071bcd2">More...</a><br /></td></tr>
<tr class="separator:ga49ea507da5177570ea74a52bb071bcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga837470f551571c81dd984a68ca7c30cf"><td class="memTemplParams" colspan="2">template&lt;typename multiloc_poptype &gt; </td></tr>
<tr class="memitem:ga837470f551571c81dd984a68ca7c30cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga837470f551571c81dd984a68ca7c30cf">KTfwd::add_mutations</a> (multiloc_poptype &amp;p, const std::size_t locus, const std::vector&lt; std::size_t &gt; &amp;indlist, const std::vector&lt; short &gt; &amp;clist, const std::vector&lt; std::size_t &gt; &amp;mutation_indexes)</td></tr>
<tr class="memdesc:ga837470f551571c81dd984a68ca7c30cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of mutations into a given locus of a multi-locus simulation.  <a href="#ga837470f551571c81dd984a68ca7c30cf">More...</a><br /></td></tr>
<tr class="separator:ga837470f551571c81dd984a68ca7c30cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecff0aaea92ec0ef0af5a541f63d822"><td class="memTemplParams" colspan="2">template&lt;typename poptype &gt; </td></tr>
<tr class="memitem:ga1ecff0aaea92ec0ef0af5a541f63d822"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d6e/group__sugar.html#ga1ecff0aaea92ec0ef0af5a541f63d822">KTfwd::change_neutral</a> (<a class="el" href="../../d5/da7/extensions_8cc.html#aa222338fad215f6f35c2f630479ddbf3">poptype</a> &amp;p, const std::size_t mindex)</td></tr>
<tr class="memdesc:ga1ecff0aaea92ec0ef0af5a541f63d822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html#acfb3b4c94516cbbc5c28a12e1ad575b3" title="Is the mutation neutral or not? ">mutation_base::neutral</a>.  <a href="#ga1ecff0aaea92ec0ef0af5a541f63d822">More...</a><br /></td></tr>
<tr class="separator:ga1ecff0aaea92ec0ef0af5a541f63d822"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Syntactic sugar for easier development of simulations. </p>
<p>See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for a full description of the features that fwdpp's sugar layer provides. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa991ef48b5f7fd6f7ea7a289e8973cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#gaa991ef48b5f7fd6f7ea7a289e8973cee">KTfwd::sugar::gsl_rng_ptr_t</a> = typedef std::unique_ptr&lt; gsl_rng, gsl_rng_deleter &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer wrapper to gsl_rng *. </p>

<p>Definition at line <a class="el" href="../../da/d16/deleter_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../da/d16/deleter_8hpp_source.html">deleter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf66ce861e458d7e15f98bbbb9e87ad38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype , typename diploid_t  = std::pair&lt;std::size_t,std::size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#gaf66ce861e458d7e15f98bbbb9e87ad38">KTfwd::metapop</a> = typedef sugar::metapop&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>, std::vector&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>&gt;, std::vector&lt;gamete&gt;, std::vector&lt;<a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a>&gt;, std::vector&lt;std::vector&lt;<a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a>&gt; &gt;, std::vector&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>&gt;, std::vector&lt;uint_t&gt;, std::unordered_set&lt;double,std::hash&lt;double&gt;,<a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single locus metapopulation simulation object. </p>

<p>Definition at line <a class="el" href="../../df/dae/metapop_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../df/dae/metapop_8hpp_source.html">metapop.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ec01f9f2a41e638a492780fdddb3048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#ga8ec01f9f2a41e638a492780fdddb3048">KTfwd::sugar::METAPOP_TAG</a> = typedef FWDPP_SUGAR_POPTAG&lt;FWDPP_SUGAR_POPTYPE::META&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Meta-population simulations. </p>

<p>Definition at line <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html">tags.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5993990a90021e4eeb4170bde943ff54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype , typename diploid_t  = std::pair&lt;std::size_t,std::size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#ga5993990a90021e4eeb4170bde943ff54">KTfwd::multiloc</a> = typedef sugar::multiloc&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>, std::vector&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>&gt;, std::vector&lt;gamete&gt;, std::vector&lt;std::vector&lt;<a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a>&gt;&gt;, std::vector&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>&gt;, std::vector&lt;uint_t&gt;, std::unordered_set&lt;double,std::hash&lt;double&gt;,<a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single population, multilocus simulation. See <a class="el" href="../../db/dd8/md_md_sugar.html">Tutorial 5: the "sugar" layer on top of fwdpp</a> for rationale, etc. </p>

<p>Definition at line <a class="el" href="../../d6/d10/multiloc_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d6/d10/multiloc_8hpp_source.html">multiloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf921d18379b491101cec5291b2e08432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#gaf921d18379b491101cec5291b2e08432">KTfwd::sugar::MULTILOCPOP_TAG</a> = typedef FWDPP_SUGAR_POPTAG&lt;FWDPP_SUGAR_POPTYPE::MULTILOC&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-population, multi-locus simulations. </p>

<p>Definition at line <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html">tags.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga618c1f80e050a17d765e89f784f6abdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mtype , typename diploid_t  = std::pair&lt;std::size_t,std::size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#ga618c1f80e050a17d765e89f784f6abdb">KTfwd::singlepop</a> = typedef sugar::singlepop&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>, std::vector&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>&gt;, std::vector&lt;gamete&gt;, std::vector&lt;<a class="el" href="../../dc/dfb/structdiploid__t.html">diploid_t</a>&gt;, std::vector&lt;<a class="el" href="../../df/d24/demography_8cc.html#a083a8b5227372e716d8614732edb6c0b">mtype</a>&gt;, std::vector&lt;uint_t&gt;, std::unordered_set&lt;double,std::hash&lt;double&gt;,<a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">KTfwd::equal_eps</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single locus, single population object. </p>

<p>Definition at line <a class="el" href="../../d5/dd9/singlepop_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d5/dd9/singlepop_8hpp_source.html">singlepop.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d1b3a08c798b89fea7c36a7180d8a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d6e/group__sugar.html#ga1d1b3a08c798b89fea7c36a7180d8a0b">KTfwd::sugar::SINGLEPOP_TAG</a> = typedef FWDPP_SUGAR_POPTAG&lt;FWDPP_SUGAR_POPTYPE::SINGLE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-population simulations. </p>

<p>Definition at line <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html#l00013">13</a> of file <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html">tags.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga6900fb51d7d4e8e89c6ce5f527eb3dad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../de/d6e/group__sugar.html#ga6900fb51d7d4e8e89c6ce5f527eb3dad">KTfwd::sugar::FWDPP_SUGAR_POPTYPE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of populations supported by sugar layer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6900fb51d7d4e8e89c6ce5f527eb3dada0679273e201afd0bf57af3961f8a23b8"></a>SINGLE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6900fb51d7d4e8e89c6ce5f527eb3dadae59f1c4fb1aa1d70a8c3eb59ff3e461b"></a>META&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6900fb51d7d4e8e89c6ce5f527eb3dadacb4eaa80f71ab986f42364e89d58684d"></a>MULTILOC&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html#l00009">9</a> of file <a class="el" href="../../d0/dd4/sugar_2poptypes_2tags_8hpp_source.html">tags.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga04107baa95fa1f3b160d7618d3369d75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../de/d6e/group__sugar.html#ga04107baa95fa1f3b160d7618d3369d75">KTfwd::sugar::GSL_RNG_TYPE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gsl_rng * types supported by fwdpp's sugar layer </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga04107baa95fa1f3b160d7618d3369d75a9628b10562b643bff5d84e6dbf17d866"></a>MT19937&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04107baa95fa1f3b160d7618d3369d75a1c61b3e6e6203fecfb58277795ad23e0"></a>TAUS2&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="../../d5/dd6/sugar_2gsl_2tags_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../d5/dd6/sugar_2gsl_2tags_8hpp_source.html">tags.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabcf95af0822bbd57f0aa85408c026201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poptype , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t KTfwd::add_mutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/extensions_8cc.html#aa222338fad215f6f35c2f630479ddbf3">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>clist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a mutation into a population at a given frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A single deme object. </td></tr>
    <tr><td class="paramname">indlist</td><td>A list of indexes of diploids into which to add the new mutations. </td></tr>
    <tr><td class="paramname">clist</td><td>A list of gametes. See below. </td></tr>
    <tr><td class="paramname">args</td><td>Values required to cosnstruct a new mutation. See below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The key referring to the location of the new mutation in the population</dd></dl>
<p>Some notes:</p>
<p>clist.size() must equal indlist.size()</p>
<p>Values in <em>clist</em> must be 0, 1, or 2. These values mean to add the mutation to the first, second, or both gametes, resepectively, of each diploid in <em>indlist</em>.</p>
<p>Note that <em>args</em> can take on a few different forms. First, it can be a raw set of values used to construct a new mutation. Or, it can be an object of correct mutation type. Or, it can be any type from which the correct mutation type can be constructed. The last two cases require that the mutation type have the appropriate constructors defined.</p>
<p>See the unit test file <a class="el" href="../../d9/dc2/test__sugar__add__mutation_8cc.html" title="test KTfwd::add_mutation ">unit/test_sugar_add_mutation.cc</a> for example of use. </p>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00223">223</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga114fed33dc72b0381c462de256f33f85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename metapoptype , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t KTfwd::add_mutation </td>
          <td>(</td>
          <td class="paramtype">metapoptype &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>demes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>indlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; short &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>clist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a mutation into a deme from a population at a given frequency in a specific set of demes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A population object. Meta- or multi-locus. </td></tr>
    <tr><td class="paramname">demes</td><td>Vector of indices of the demes in which to add mutation. </td></tr>
    <tr><td class="paramname">indlist</td><td>A list of indexes of diploids into which to add the new mutations in each deme. </td></tr>
    <tr><td class="paramname">clist</td><td>A list of gametes. See below. </td></tr>
    <tr><td class="paramname">args</td><td>Values required to cosnstruct a new mutation. See below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The key referring to the location of the new mutation in the population</dd></dl>
<p>Some notes:</p>
<p>clist.size() must equal indlist.size() must equal demes.size()</p>
<p>Further, each element of clist must equal each element of indlist in size.</p>
<p>Values in <em>clist</em> must be 0, 1, or 2. These values mean to add the mutation to the first, second, or both gametes, resepectively, of each diploid in <em>indlist</em>.</p>
<p>Note that <em>args</em> can take on a few different forms. First, it can be a raw set of values used to construct a new mutation. Or, it can be an object of correct mutation type. Or, it can be any type from which the correct mutation type can be constructed. The last two cases require that the mutation type have the appropriate constructors defined.</p>
<p>See the unit test file <a class="el" href="../../d9/dc2/test__sugar__add__mutation_8cc.html" title="test KTfwd::add_mutation ">unit/test_sugar_add_mutation.cc</a> for example of use. </p>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00278">278</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c8184c8c27beb420671af0546904661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename multiloc_poptype , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t KTfwd::add_mutation </td>
          <td>(</td>
          <td class="paramtype">multiloc_poptype &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>locus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>clist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a mutation into a population at a given frequency at in a specific locus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A population object. Meta- or multi-locus. </td></tr>
    <tr><td class="paramname">locus</td><td>Index of the locus in which to add mutation. </td></tr>
    <tr><td class="paramname">indlist</td><td>A list of indexes of diploids into which to add the new mutations. </td></tr>
    <tr><td class="paramname">clist</td><td>A list of gametes. See below. </td></tr>
    <tr><td class="paramname">args</td><td>Values required to cosnstruct a new mutation. See below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing (void) </dd>
<dd>
The key referring to the location of the new mutation in the population</dd></dl>
<p>Some notes:</p>
<p>clist.size() must equal indlist.size()</p>
<p>Values in <em>clist</em> must be 0, 1, or 2. These values mean to add the mutation to the first, second, or both gametes, resepectively, of each diploid in <em>indlist</em>.</p>
<p>Note that <em>args</em> can take on a few different forms. First, it can be a raw set of values used to construct a new mutation. Or, it can be an object of correct mutation type. Or, it can be any type from which the correct mutation type can be constructed. The last two cases require that the mutation type have the appropriate constructors defined.</p>
<p>See the unit test file <a class="el" href="../../d9/dc2/test__sugar__add__mutation_8cc.html" title="test KTfwd::add_mutation ">unit/test_sugar_add_mutation.cc</a> for example of use. </p>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00344">344</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga34c0af3daeea9be414949bedf525f160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::add_mutations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/extensions_8cc.html#aa222338fad215f6f35c2f630479ddbf3">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>clist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutation_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of mutations into a set of individuals in a population. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A population object. Meta- or multi-locus. </td></tr>
    <tr><td class="paramname">indlist</td><td>A list of indexes of diploids into which to add the new mutations. </td></tr>
    <tr><td class="paramname">clist</td><td>A list of gametes. See below. </td></tr>
    <tr><td class="paramname">mutation_indexes</td><td>The set of mutations to add. See below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing (void)</dd></dl>
<p>Some notes:</p>
<p>clist.size() must equal indlist.size()</p>
<p>Values in <em>clist</em> must be 0, 1, or 2. These values mean to add the mutation to the first, second, or both gametes, resepectively, of each diploid in <em>indlist</em>.</p>
<dl class="section note"><dt>Note</dt><dd><em>mutation_indexes</em> refers to the locations of mutations found in <em>p.mutations</em>.</dd>
<dd>
For each element, i, in <em>mutation_indexes</em>, <em>p.mcounts</em>[i] should be zero before entering this function.</dd>
<dd>
<em>p.mut_lookup</em> is NOT updated by this function.</dd></dl>
<p>See the unit test file <a class="el" href="../../d9/dc2/test__sugar__add__mutation_8cc.html" title="test KTfwd::add_mutation ">unit/test_sugar_add_mutation.cc</a> for example of use. </p>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00399">399</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga49ea507da5177570ea74a52bb071bcd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename metapoptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::add_mutations </td>
          <td>(</td>
          <td class="paramtype">metapoptype &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>demes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>indlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; short &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>clist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutation_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of mutation into a deme from a population at a given frequency in a specific set of demes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A population object. Meta- or multi-locus. </td></tr>
    <tr><td class="paramname">demes</td><td>Vector of indices of the demes in which to add mutation. </td></tr>
    <tr><td class="paramname">indlist</td><td>A list of indexes of diploids into which to add the new mutations in each deme. </td></tr>
    <tr><td class="paramname">clist</td><td>A list of gametes. See below. </td></tr>
    <tr><td class="paramname">mutation_indexes</td><td>Keys to mutations in p.mutations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing (void)</dd></dl>
<p>Some notes:</p>
<p>clist.size() must equal indlist.size()</p>
<p>Values in <em>clist</em> must be 0, 1, or 2. These values mean to add the mutation to the first, second, or both gametes, resepectively, of each diploid in <em>indlist</em>.</p>
<dl class="section note"><dt>Note</dt><dd><em>mutation_indexes</em> refers to the locations of mutations found in <em>p.mutations</em>.</dd>
<dd>
For each element, i, in <em>mutation_indexes</em>, <em>p.mcounts</em>[i] should be zero before entering this function.</dd>
<dd>
<em>p.mut_lookup</em> is NOT updated by this function.</dd></dl>
<p>See the unit test file <a class="el" href="../../d9/dc2/test__sugar__add__mutation_8cc.html" title="test KTfwd::add_mutation ">unit/test_sugar_add_mutation.cc</a> for example of use. </p>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00455">455</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga837470f551571c81dd984a68ca7c30cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename multiloc_poptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::add_mutations </td>
          <td>(</td>
          <td class="paramtype">multiloc_poptype &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>locus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>clist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutation_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of mutations into a given locus of a multi-locus simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A population object. Meta- or multi-locus. </td></tr>
    <tr><td class="paramname">locus</td><td>Index of the locus in which to add mutation. </td></tr>
    <tr><td class="paramname">indlist</td><td>A list of indexes of diploids into which to add the new mutations. </td></tr>
    <tr><td class="paramname">clist</td><td>A list of gametes. See below. </td></tr>
    <tr><td class="paramname">mutaton_indexes</td><td>Keys to mutations in p.mutations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing (void)</dd></dl>
<p>Some notes:</p>
<p>clist.size() must equal indlist.size()</p>
<p>Values in <em>clist</em> must be 0, 1, or 2. These values mean to add the mutation to the first, second, or both gametes, resepectively, of each diploid in <em>indlist</em>.</p>
<dl class="section note"><dt>Note</dt><dd><em>mutation_indexes</em> refers to the locations of mutations found in <em>p.mutations</em>.</dd>
<dd>
For each element, i, in <em>mutation_indexes</em>, <em>p.mcounts</em>[i] should be zero before entering this function.</dd>
<dd>
<em>p.mut_lookup</em> is NOT updated by this function.</dd></dl>
<p>See the unit test file <a class="el" href="../../d9/dc2/test__sugar__add__mutation_8cc.html" title="test KTfwd::add_mutation ">unit/test_sugar_add_mutation.cc</a> for example of use. </p>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00521">521</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ecff0aaea92ec0ef0af5a541f63d822"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::change_neutral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/extensions_8cc.html#aa222338fad215f6f35c2f630479ddbf3">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>mindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html#acfb3b4c94516cbbc5c28a12e1ad575b3" title="Is the mutation neutral or not? ">mutation_base::neutral</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A population </td></tr>
    <tr><td class="paramname">mindex</td><td>The key of the mutation you wish to change.</td></tr>
  </table>
  </dd>
</dl>
<p>This function changes <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html#acfb3b4c94516cbbc5c28a12e1ad575b3" title="Is the mutation neutral or not? ">mutation_base::neutral</a> to !mutation_base::neutral at position mindex and updates the storage of this mutation in all gametes.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not change any other member data at p.mutations[mindex]!! Thus, if you change a mutation from "neutral" to "selected", you must manually change the relevant member data to reflect its new effect size. For the simplest use case of making a mutation no longer subject to selection, no additional changes are needed. Rather, it is sufficient that <a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html#acfb3b4c94516cbbc5c28a12e1ad575b3" title="Is the mutation neutral or not? ">mutation_base::neutral</a> == true.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <em>mindex</em> is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/dcb/change__neutral_8hpp_source.html#l00054">54</a> of file <a class="el" href="../../dd/dcb/change__neutral_8hpp_source.html">change_neutral.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga20e03e38a69ea6103541149318de36fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mcont_t , typename mcounts_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t KTfwd::sugar::get_mut_index </td>
          <td>(</td>
          <td class="paramtype">mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mcounts_t &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename mcont_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>new_mutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for implementing <a class="el" href="../../de/d6e/group__sugar.html#gabcf95af0822bbd57f0aa85408c026201" title="Add a mutation into a population at a given frequency. ">KTfwd::add_mutation</a>. </p>
<p>If <em>new_mutation</em> already exists in <em>mutations</em>, its location is returned.</p>
<p>Otherwise, this function puts the new mutation into the mutations container and updates other objects as needed.</p>
<dl class="section return"><dt>Returns</dt><dd>A key telling where <em>new_mutation</em> exists within <em>mutations</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires that operator== be defined for the mutation type.</dd>
<dd>
In the event that <em>new_mutation</em> is added to <em>mutations</em>, the count for that mutations will be zero. </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d1/d87/add__mutation_8hpp_source.html">add_mutation.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
