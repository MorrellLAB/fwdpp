<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: Tutorial 2: Implementing multilocus simulations</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 2: Implementing multilocus simulations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In order to simulate discontiguous genomic segments, one has two options within <b>fwdpp</b>:</p>
<ol type="1">
<li>Write mutation, recombination, and fitness policies that "do the right thing" for your model. For example, a mutation policy would need to know about the mutation rate at each locus, and appropriately assign mutations with the correct positions, fitness effects, etc.</li>
<li>Write separate mutation and recombination policies for each locus, and a fitness policy that calculates the fitness of a diploid over all loci.</li>
</ol>
<p>This document covers the latter method, which I call the "multilocus" part of <b>fwdpp</b>. I won't give any examples of the former method, as I'm opposed to the idea of having to develop, debug, and mainting large complex policies. But if you want to do things that way, read the <a class="el" href="../../d1/d7a/md_md_policies.html">tutorial on policies</a>, because what you are looking for is all in there.</p>
<h1>Simple policies using the multi-locus machinery</h1>
<p>The main conceptual difference between this part of the library and the examples shown in the <a class="el" href="../../d1/d7a/md_md_policies.html">tutorial on policies</a> is the following:</p>
<ul>
<li>Instead of a single mutation model policy, you implement one mutation model per "locus". These policies are stored in a vector and passed to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a18df6351fa3148914bbb844c36bc3e05">KTfwd::sample_diploid</a>.</li>
<li>Similarly, you implement a recombination policy per locus, and pass a vector of those policies along to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a18df6351fa3148914bbb844c36bc3e05">KTfwd::sample_diploid</a>.</li>
<li>Instead of a single list of gametes, you have a vector of lists of gametes, where each list represents the current gametes at a particular locus.</li>
<li>A diploid is now represented as a vector of pairs of iterators derived from the vector of lists of gametes.</li>
<li>A fitness policy calculates individual fitnesses from an iterator pointing to that vector of pairs of iterators.</li>
</ul>
<p>At this point, it may be most useful to look at a concrete example. The program <a class="el" href="../../de/dce/diploid__ind__2locus_8cc.html">diploid_ind_2locus.cc</a> is distributed with the library source code, and we'll break down its essential parts in the next few sections.</p>
<h3>A multilocus mutation model</h3>
<p>For this example, we simulate only neutral mutations, and the model has two loci. Our function to return a new mutation will do the following:</p>
<ol type="1">
<li>Take the start position of a locus as an argument.</li>
<li>Return a new mutations whose position is uniformly-distributed on in interval <img class="formulaInl" alt="$(\mathrm{start},\mathrm{start}+1]$" src="../../form_33.png"/></li>
</ol>
<p>This is our mutation class:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../dc/dcc/structKTfwd_1_1popgenmut.html">mutation_with_age</a> : <span class="keyword">public</span> <a class="code" href="../../d1/da4/structKTfwd_1_1mutation__base.html">KTfwd::mutation_base</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> <a class="code" href="../../dc/dcc/structKTfwd_1_1popgenmut.html#af42aac73b0fef6d2b1990b110bc3d4c9">g</a>;</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="../../dc/dcc/structKTfwd_1_1popgenmut.html#ae055d7d981b19117c04def0dcc57e310">s</a>,<a class="code" href="../../dc/dcc/structKTfwd_1_1popgenmut.html#a60a395a305fd9d0a1f3da6b7b223bc10">h</a>;</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">    The constructor initializes all class data, including that of the base class via a constructor</span></div>
<div class="line"><span class="comment">    call to the base class.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  mutation_with_age(const unsigned &amp; __o,const double &amp; position, const unsigned &amp; count, const bool &amp; isneutral = true)</span></div>
<div class="line"><span class="comment">    : KTfwd::mutation_base(position,count,isneutral),g(__o),s(0.),h(0.)</span></div>
<div class="line"><span class="comment">  {     </span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">};</span></div>
</div><!-- fragment --><p>It contains info for selection coefficients, etc., but we won't be using any of that. (It is only there b/c I use the same mutation object for all of the example programs...)</p>
<p>Given the requirements outlined above, a function to return a mutation at a specific locus is:</p>
<div class="fragment"><div class="line"><span class="comment">//&quot;beg&quot; is the start position of this locus</span></div>
<div class="line"><a class="code" href="../../dc/dcc/structKTfwd_1_1popgenmut.html">mutation_with_age</a> neutral_mutations_inf_sites(gsl_rng * r,<span class="keyword">const</span> <span class="keywordtype">unsigned</span> * generation,mlist * mutations,</div>
<div class="line">                                              <a class="code" href="../../d8/d48/bneck__selection__dist_8cc.html#a0731e2ed14d3858427a2552e4944b778">lookup_table_type</a> * lookup, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; beg)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//Generate new mutation position on the interval [0,1)</span></div>
<div class="line">  <span class="keywordtype">double</span> pos = gsl_ran_flat(r,beg,beg+1.);</div>
<div class="line">  <span class="keywordflow">while</span>( lookup-&gt;find(pos) != lookup-&gt;end() ) <span class="comment">//make sure it doesn&#39;t exist in the population</span></div>
<div class="line">    { </div>
<div class="line">      pos = gsl_ran_flat(r,beg,beg+1.);</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">//update the lookup table</span></div>
<div class="line">  lookup-&gt;insert(pos);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//In absence of DEBUG, make sure lookup table is working</span></div>
<div class="line">  assert(std::find_if(mutations-&gt;begin(),mutations-&gt;end(),std::bind(<a class="code" href="../../d5/d1a/structKTfwd_1_1mutation__at__pos.html">KTfwd::mutation_at_pos</a>(),std::placeholders::_1,pos)) == mutations-&gt;end());</div>
<div class="line"></div>
<div class="line">  <span class="comment">//return constructor call to mutation type</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="../../d0/db9/sugar1_8cc.html#a26022ef252703a27f414647b9ad246a8">mutation_with_age</a>(*generation,pos,1,<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The details of the lookup table are covered in the main <a class="el" href="../../d1/d7a/md_md_policies.html">tutorial</a> on policies. It serves to efficiently ensure that we are sampling new mutation positions from an infinitely-many sites model.</p>
<p>We may now create mutation model policies by synthesizing a function call that returns a mutation_with_age using <a href="http://en.cppreference.com/w/cpp/utility/functional/bind">std::bind</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mmodel0 = std::bind(neutral_mutations_inf_sites,r,&amp;generation,std::placeholders::_1,&amp;lookup,0.);</div>
<div class="line"><span class="keyword">auto</span> mmodel1 = std::bind(neutral_mutations_inf_sites,r,&amp;generation,std::placeholders::_1,&amp;lookup,1.);</div>
</div><!-- fragment --><p>The placeholder is for a pointer to a doubly-linked list of mutations (see argument 3 in the definition of neutral_mutations_inf_sites above). Each of these is identical to what we do in a single-locus simulation. The only "trick" here is that we pass a 0 to mmodel0, and a 1 to mmodel1 to represent the starting position for each locus, thus guaranteeing that neutral_mutations_inf_sites returns a mutation with positions <img class="formulaInl" alt="$(0,1]$" src="../../form_34.png"/> or <img class="formulaInl" alt="$(1,2]$" src="../../form_35.png"/>.</p>
<p>We need to store these policies in a vector. The easiest way to do that is to use the C++11 features <a href="http://en.cppreference.com/w/cpp/language/decltype">decltype</a> and <a href="http://en.cppreference.com/w/cpp/language/list_initialization">list initialization</a>:</p>
<div class="fragment"><div class="line">std::vector&lt;decltype(mmodel0)&gt; mmodels { mmodel0, mmodel1 };</div>
</div><!-- fragment --><h3>Caveat: vectors of policies containing values captured in lambda expressions.</h3>
<p>The above examples all consider a fixed number of loci. However, if the number of loci is to be determined at run-time, then your mutation models, etc., will need to be created dynamically. When using <em>lambda expressions</em>, be sure to capture <em>by value</em> and not <em>by reference</em>. For example, this loop results in a vector of mutation policies where mutation positions at the <img class="formulaInl" alt="$i^{th}$" src="../../form_36.png"/> locus are continuous on the interval <img class="formulaInl" alt="$[i,i+1)$" src="../../form_37.png"/>:</p>
<div class="fragment"><div class="line">std::vector&lt; std::function&lt;mtype(multiloc_t::mlist_t *)&gt; &gt; mmodels;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0 ; i &lt; nloci ; ++i)</div>
<div class="line">        {</div>
<div class="line">        <span class="comment">//Establish the range of positions for this locus</span></div>
<div class="line">          <span class="keywordtype">double</span> a=i,b=i+1;</div>
<div class="line">          mmodels.push_back(std::bind(<a class="code" href="../../df/d07/structKTfwd_1_1infsites.html">KTfwd::infsites</a>(),r.get(),&amp;pop.mut_lookup,&amp;generation,</div>
<div class="line">        <span class="comment">//Capture a,b by VALUE!  Otherwise, they go out of scope and bad things can happen!</span></div>
<div class="line">                mu[i],0.,[&amp;<a class="code" href="../../d9/d1d/mlocusCrossoverTest_8cc.html#a53b3e4bb1bd287d2150b9c128e15a316">r</a>,a,b](){ <span class="keywordflow">return</span> gsl_ran_flat(r.get(),a,b);},[](){<span class="keywordflow">return</span> 0.;},[](){<span class="keywordflow">return</span> 0.;}));</div>
<div class="line">        }</div>
</div><!-- fragment --><p>Keep this in mind for all containers of policies (in addition to this mutation example).</p>
<h3>Digression: type signatures for for policies</h3>
<p>The multilocus API requires that the user pass a vector of policies. A vector's interface further requires that all elements contained by a vector are of the same type. In the previous section, we used C++11's <a href="http://en.cppreference.com/w/cpp/language/auto">auto</a> keyword to force the compiler to figure out the type of mmodel0 and mmodel1. It just so happens that they are of the same type, which I think should be obvious if we consider that both are calls to std::bind with the same number of arguments, all of which are the same type.</p>
<p>Some users may try to implement the mutation models using C++11 <a href="http://en.cppreference.com/w/cpp/language/lambda">lambda expressions</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mmodel0 = [&amp;]( mlist * m ) { <span class="keywordflow">return</span> neutral_mutations_inf_sites(r,&amp;generation,m,&amp;lookup,0.); };</div>
<div class="line"><span class="keyword">auto</span> mmodel1 = [&amp;]( mlist * m ) { <span class="keywordflow">return</span> neutral_mutations_inf_sites(r,&amp;generation,m,&amp;lookup,1.); };</div>
<div class="line">std::vector&lt; decltype(mmodel0) &gt; mmodels { mmodel0, mmodel1 };</div>
</div><!-- fragment --><p>However, the above approach will fail because C++11 lambda expressions always have different types, even if their signatures are the same, as in the case above (both lambdas take the same number of arguments, all arguments are the same type, and the return value is the same). In order to use lambda expressions for our mutation models, our vector of policies will have to specify a particular function signature for its object type using <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>:</p>
<div class="fragment"><div class="line">std::vector&lt; std::function&lt;mutation_with_age(mlist *)&gt; &gt; mmodels {mmodel0,mmodel1};</div>
</div><!-- fragment --><p>Personally, I prefer the std::bind/decltype idiom here over the lambda/std::function approach, because it means less work on my part. However, the latter method can win you the greatest number of geek points because it allows you to do everything in one fell swoop and write code that is arguably harder to read:</p>
<div class="fragment"><div class="line">std::vector&lt; std::function&lt;mutation_with_age(mlist *)&gt; &gt; mmodels {</div>
<div class="line">        [&amp;]( mlist * m ) { <span class="keywordflow">return</span> neutral_mutations_inf_sites(r,&amp;generation,m,&amp;lookup,0.); },</div>
<div class="line">        [&amp;]( mlist * m ) { <span class="keywordflow">return</span> neutral_mutations_inf_sites(r,&amp;generation,m,&amp;lookup,1.); }</div>
<div class="line">        };</div>
</div><!-- fragment --><p>In summary, we have to pay some attention to the type signatures of our policies, and lambda expressions require some special care. We don't have to be aware of this stuff in the single-locus API, because we can rely on the compiler to just work it out for itself during template insantiation.</p>
<h3>Separate within-locus recombination policies</h3>
<p>Our with-locus recombination models will be very simple, and will model recombination as a uniform process. The genetic maps can therefore be defined as:</p>
<div class="fragment"><div class="line">std::function&lt;double(void)&gt; recmap = std::bind(gsl_rng_uniform,r),</div>
<div class="line">        recmap2 = std::bind(gsl_ran_flat,r,1.,2.);</div>
</div><!-- fragment --><p>We use the above genetic maps to synthesize recombination policies:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> recpol0 = std::bind(<a class="code" href="../../d1/d5b/structKTfwd_1_1genetics101.html">KTfwd::genetics101</a>(),std::placeholders::_1,std::placeholders::_2,std::placeholders::_3,&amp;gametes,littler,r,recmap);</div>
<div class="line"><span class="keyword">auto</span> recpol1 = std::bind(<a class="code" href="../../d1/d5b/structKTfwd_1_1genetics101.html">KTfwd::genetics101</a>(),std::placeholders::_1,std::placeholders::_2,std::placeholders::_3,&amp;gametes,littler,r,recmap2);</div>
<div class="line">std::vector&lt; decltype(recpol0) &gt; recpols{ recpol0 , recpol1 };</div>
</div><!-- fragment --><p>Why did I declare the recmaps with std::function instead of auto? The reason is that the type deduction is more complex here, and the compiler will deduce bizarre signatures for recmap and recmap2 if left to its own devices. I am still exploring if this can be addressed in the future to allow automatic type deduction via auto/decltype.</p>
<h3>Recombination between loci</h3>
<p>To model recombination between loci, you need the following two ingredients:</p>
<ol type="1">
<li>An array of doubles of length <img class="formulaInl" alt="$L-1$" src="../../form_38.png"/>, where <img class="formulaInl" alt="$L$" src="../../form_39.png"/> is the number of loci in the simulation.</li>
<li>A policy specifying how to apply those values. For example, you may choose to model crossing over between loci as a binomial process or a Poisson process. This policy must return an unsinged integer, representing the number of crossovers between loci <img class="formulaInl" alt="$i$" src="../../form_40.png"/> and <img class="formulaInl" alt="$i-1$" src="../../form_41.png"/> ( <img class="formulaInl" alt="$1 \leq i \leq L-1$" src="../../form_42.png"/>). What really matters is that the return value from this policy is odd or even.</li>
</ol>
<p>In our simulation, there are only two loci, so our array may be defined as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> rbw = 0. <span class="comment">//no crossing over between loci</span></div>
</div><!-- fragment --><p>And we model crossing over between loci as a Poisson process using a lambda expression:</p>
<div class="fragment"><div class="line">[](gsl_rng * __r, <span class="keyword">const</span> <span class="keywordtype">double</span> __d){ <span class="keywordflow">return</span> gsl_ran_poisson(__r,__d); }</div>
</div><!-- fragment --><p>Obviously, for this specific example, having no crossover between loci (rbw = 0) make this policy irrelevant, but it does matter in general.</p>
<h4>Poisson or not?</h4>
<p>Biologically, the interpretation of the values in the array of doubles matters. For example, let's assume that we wanted to model two unlinked loci. Our genetic classes tell us that this corresponds to:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> rbw = 0.5; <span class="comment">//50 centiMorgans</span></div>
</div><!-- fragment --><p>However, that value of 0.5 correponds to the probability of success in a single Bernoulli trial, because the definition of the <img class="formulaInl" alt="$r$" src="../../form_12.png"/> term from genetics is the probability that markers separated by that distance are observed to have recombined in the progeny. If we were to pass 0.5 and a Poisson model like the one above, there would only be a recombinant about 30% of the time, which you can verify using R (noting that an odd number of crossovers corresponds to the terminal ends of the region being recombined in the offspring):</p>
<div class="fragment"><div class="line">&lt;blockquote&gt;</div>
<div class="line">x=rpois(1e6,0.5)</div>
<div class="line">length(which (x%%2==1))/length(x)</div>
<div class="line"></div>
<div class="line">&lt;/blockquote&gt;</div>
<div class="line">[1] 0.315705</div>
</div><!-- fragment --><p>Of course, for small <img class="formulaInl" alt="$r$" src="../../form_12.png"/>, the Poisson and the Binomial approach would give very similar results. But, for larger <img class="formulaInl" alt="$r$" src="../../form_12.png"/>, be sure to model what you mean!</p>
<h3>A (trivial) mutilocus fitness model</h3>
<p>In this example program, there is no selection, so our fitness model will return 1 for the fitness of any diploid. Just like the single-locus API, multilocus fitness policies take a diploid as an argument and return a double. The difference here is that a diploid is now a vector of pairs of iterators to gametes:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d8/df2/structno__selection__multi.html">no_selection_multi</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> <a class="code" href="../../d8/df2/structno__selection__multi.html#ac8d3abd4176b215a58de070fe9111483">result_type</a>;</div>
<div class="line">  <span class="comment">//The template type is an iterator derived from the vector containing the diploids,</span></div>
<div class="line">  <span class="comment">//and therefore points to a std::vector&lt; std::pair&lt;gamete_itr_t,gamete_itr_r&gt; &gt;,</span></div>
<div class="line">  <span class="comment">//where the gamete_itr_t are iterators pointing to gametes</span></div>
<div class="line">  <span class="keyword">template</span>&lt; <span class="keyword">typename</span> dipo<span class="keywordtype">id</span>_vec_itr_t &gt;</div>
<div class="line">  <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="../../d8/df2/structno__selection__multi.html#ae0a0cfe8318bd927bc12cf864abe2dc4">operator()</a>( <span class="keyword">const</span> diploid_vec_itr_t &amp; diploid )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> 1.;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h3>Calling sample_diploid</h3>
<p>The above definitions are used to evolve a population via a call to <a class="el" href="../../da/d8b/namespaceKTfwd.html#a18df6351fa3148914bbb844c36bc3e05">KTfwd::sample_diploid</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d8b/namespaceKTfwd.html#a18df6351fa3148914bbb844c36bc3e05">KTfwd::sample_diploid</a>( r,</div>
<div class="line">        &amp;gametes,</div>
<div class="line">        &amp;diploids,</div>
<div class="line">        &amp;mutations,</div>
<div class="line">        N,</div>
<div class="line">        N,</div>
<div class="line">        &amp;mu[0],</div>
<div class="line">        mmodels,</div>
<div class="line">        recpols,</div>
<div class="line">        &amp;rbw,</div>
<div class="line">        [](gsl_rng * __r, <span class="keyword">const</span> <span class="keywordtype">double</span> __d){ <span class="keywordflow">return</span> gsl_ran_poisson(__r,__d); },</div>
<div class="line">        std::bind(KTfwd::insert_at_end&lt;mtype,mlist&gt;,std::placeholders::_1,std::placeholders::_2),</div>
<div class="line">        std::bind(KTfwd::insert_at_end&lt;gtype,glist&gt;,std::placeholders::_1,std::placeholders::_2),</div>
<div class="line">        std::bind(<a class="code" href="../../d8/df2/structno__selection__multi.html">no_selection_multi</a>(),std::placeholders::_1),</div>
<div class="line">        std::bind(<a class="code" href="../../d4/de8/structKTfwd_1_1mutation__remover.html">KTfwd::mutation_remover</a>(),std::placeholders::_1,0,2*N),</div>
<div class="line">        0.);</div>
</div><!-- fragment --><p>The above call is very similar to the single-locus method, except that vectors of policies are passed. Two other differences are:</p>
<ol type="1">
<li>We need an array of per-locus mutation rates. This should be a double * of length <img class="formulaInl" alt="$L$" src="../../form_39.png"/>, and &amp;mu[0] passes that pointer on to the mutation policies.</li>
<li>We include our Poisson model of interlocus recombination.</li>
</ol>
<p>At this point, you are probably ready to see the full implementation of <a class="el" href="../../de/dce/diploid__ind__2locus_8cc.html">diploid_ind_2locus.cc</a> for the remaining details.</p>
<h1>Sampling from a multilocus simulation</h1>
<p>To take a sample of size <img class="formulaInl" alt="$n \ll N$" src="../../form_43.png"/> from the population, you may make a call to either <a class="el" href="../../d7/de2/group__samplingPopsInd.html#ga2e9aee81e0abaddbb9c6e56f0d8f980f" title="Sampling from a population in an individual-based simulation. ">KTfwd::ms_sample</a>, which returns all neutral selected mutations in a single block, or <a class="el" href="../../d7/de2/group__samplingPopsInd.html#ga235b4507a6f09b26fa9b33ef12abf59d" title="Sampling from a population in an individual-based simulation. Selected and neutral mutations returned...">KTfwd::ms_sample_separate</a>, which returns separate blocks for the selected and neutral mutations.</p>
<h1>Serialization: in-memory copying and file I/O</h1>
<p>See the <a class="el" href="../../d5/d9d/md_md_serialization.html">tutorial on serialization</a>.</p>
<h2>Mechanics of the multilocus recombination</h2>
<p>If anyone is interested in how the book-keeping for multilocus recombination works, see the library file <a class="el" href="../../d7/d48/multilocus__rec_8hpp.html">multilocus_rec.hpp</a>, which defines the function KTfwd::fwdpp_internal::multilocus_rec. You can also look at the unit test code <a class="el" href="../../d9/d1d/mlocusCrossoverTest_8cc.html" title="Tests KTfwd::fwdpp_internal::multilocus_rec. ">mlocusCrossoverTest.cc</a>, which implements manually-concocted examples to make sure that the outcomes of these functions are correct (which means that I can write down what should happen on paper, and I get the same result from the unit test). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
