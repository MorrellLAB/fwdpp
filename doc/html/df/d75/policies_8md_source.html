<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>fwdpp: md/policies.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.4.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">md/policies.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../df/d75/policies_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Tutorial 1: Policies in fwdpp</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;[TOC]</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;\section TutIntro Introduction</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;This document is intended to be an in-depth discussion of policies and their role in implementing forward-time population genetic simulations using the C++ template library __fwdpp__.  We will first describe what policies are using standard C++ examples, and then we will get into the harder stuff.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;In this document, I am implictly assuming that the library is being used to implement what I refer to as a &quot;single-locus&quot; simulation, by which I mean the simulation of a contiguous genomic stretch to which we apply some arbitrary model of mutation, recombination, and fitness.  It is possible to use the same machinery to implement a &quot;multi-locus&quot; model of non-contiguous genomic segments, each with different mutation models, recombination models, and arbitrary linkage relationships amongst them.  However, such simulations are arguably easier to impement using the multilocus API provided by the library, and I refer the users to the [documentation](@ref md_md_multiloc) for that part of the library.</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;An understanding of C++ fundamentals, including containers, their iterators, and how they relate to the standard algorithms, is assumed knowledge here.</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;\section TutGeneral Policies in C++</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## Policies are everywhere</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Policies are a part of every programming language.  Generally-speaking, they modify the behavior of what functions are with (or to) data.  In other words, they turn a generic function into a piece of code doing a specific task.  Let&#39;s start with the rather trivial example of sorting a vector:</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;#include &lt;algorithm&gt;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;#include &lt;vector&gt;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;using namespace std;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;int main ( int argc, char ** argv )</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;{</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  vector&lt;unsigned&gt; vu{10,9,8,7,6,5,4,3,2,1};</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  sort(vu.begin(),vu.end());</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;~~~</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;The above example is 100\% standard C++.  But what is going on under the hood of the sort function is quite interesting.  A sort algorithm is being executed, and the values are being compared via a call to this function:</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;template &lt;class T&gt; struct less : binary_function &lt;T,T,bool&gt; {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    //algorithms can&#39;t guess return types,</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    //and therefore often need this typedef</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    typedef bool result_type;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;bool operator() (const T&amp; x, const T&amp; y) const {return x&lt;y;}</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  };</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;~~~</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;## Policies are often function objects</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;The structure called less is a &quot;function object&#39;&#39;, and is the policy being employed in the sort.  Further, is a template, meaning it works on any data type for which the &quot;less than&quot; operator is defined, e.g., any type for which this code is valid:</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;if ( a &lt; b )</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;}</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;~~~</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;The detail that less inherits from __std::binary\_function__ is important for how it plugs into the sort algorithm, but we&#39;ll deal with those issues later.</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;The way such a function object is used looks like:</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;int x = 5, y = 6;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  /*</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  The less() instantiates a (temporary) object of type less&lt;T&gt;,</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  where T = int in this case.</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  the (x,y) passes those to variables to the operator() of less.</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  (This is where the term</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  &quot;function object&#39;&#39;, or functor for short, comes from.)</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  */</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  bool x_is_less = less()(x,y);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;~~~</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;### Policies change behavior of algorithms</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;OK, so now we hopefully have a basic understanding of what a policy is and that algorithms in C++ work through policies implemented as function objects.  This lets us change the behavior of algorithms:</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  #include &lt;functional&gt; //need this header for std::greater&lt;T&gt;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  //Sort in descending order (biggest values @ front of vu after sort)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  sort( vu.begin(), vu.end(), greater&lt;int&gt;() );</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;~~~</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;Same sort, different outcome because of different policy.</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;### Binding extends what policies can do</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;We can further modify the behavior of policies by sending additional arguments along with the policy as it goes to the algorithm.  This is called binding an argument to a function call. For example, let&#39;s find the first value in our vector that is &gt;= 5:</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  //we need these headers</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  #include &lt;functional&gt;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  #include &lt;iostream&gt;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  vector&lt;unsigned&gt;::iterator itr = find_if( vu.begin(), </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  vu.end(), </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  bind2nd( greater_equal&lt;int&gt;(), 5 ) );</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  //print out the value pointed to by the iterator, </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  //if and only if we found something.  In C++,</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  //when a policy never finds anything, </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  //the end of the container is returned by tradition</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  if( itr != vu.end() )</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    cout &lt;&lt; *itr &lt;&lt; &#39;\n&#39;;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  }</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;~~~</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;The find_if algorithm takes each value in the range and evaluates it via the policy.  Here, the policy is greater_equal, which takes two arguments.  The second argument is provided by using the standard-library function bind2nd, which results in the value 5 being the second value passed to the policy&#39;s operator().  The new binders in C++11 are much better:</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  //we need these headers</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  #include &lt;functional&gt;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  #include &lt;iostream&gt;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  vector&lt;unsigned&gt;::iterator itr = find_if( vu.begin(), </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  vu.end(), </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  //here, _1 is a placeholder for a value that the algorithm must provide</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  std::bind( greater_equal&lt;int&gt;(),std::placeholders::_1, 5 ) );</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  //print out the value pointed to by the iterator, </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  //if and only if we found something.  In C++,</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  //when a policy never finds anything, </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  //the end of the container is returned by tradition</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  if( itr != vu.end() )</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    cout &lt;&lt; *itr &lt;&lt; &#39;\n&#39;;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  }</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;~~~</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;## Summary so far</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;* Policies change how algorithms behave</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;* Policies are often templates</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;* Policies are often function objects</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;* Policies + binders + algorithms = a reusable code base that can do lots of different (and often quite complicated) things when the right policy is written.</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;* Policies can often be quite short to implement (see the definition of less above).  This doesn&#39;t have to be the case, but it often works out that way in practice.</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;\section TutAlgo Algorithms in fwdpp</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;For individual-based simulations, the primary algorithms are __KTfwd::sample\_diploid__ and __KTfwd::update\_mutations__.  All of these functions are in the name space __KTfwd__ and are documented both in the source code, via the doxygen output based on the source code, and finally in the example code that comes with the library.</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;Some of the code in some of these algorithms is quite complex, largely because generic templates can have hideous syntax.  You should&#39;t have to worry about that unless you like seeing how the sausage is made.  Most users of __fwdpp__ will be writing custom policies to stick into these algorithms and will likely be starting from the examples in order to get oriented.  For them, the necessary information is to understand what is required of a policy.  That is the subject of the remainder of this document.</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;\section TutPolicies Policy requirements in fwdpp</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;This section discusses the requirements placed on policies in __fwdpp__.  These requirements are essentially standards placed on data types in order to ensure that simulations behave properly. (Note that &quot;&quot;behave properly&#39;&#39; is not the same as &quot;are implemented correctly&#39;&#39;!  It is totally possible to have a simulation that compiles with no warnings and runs without crashing but is not the model you had in mind.)  The policy requirements are enforced during compilation, such that a nonconforming policy cannot result in a compiled simulation program.</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;In the following sections, we will discuss policy requirements, how the built-in policies work, and also create some new policies.  We&#39;ll build some policies for a simple quantitative trait with selection simulation, and later on combine them all to see how __KTfwd::sample\_diploid__ would actually be called (for the case of a constant-sized population in an individual-based simulation).  For additional and more complex examples, see the code for the example programs that come with the library.</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;Caveat emptor:</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;1. This document has been written ad lib, and there may be errors in the implementation of policies below.  (The policies that are directly from the library have been copy/pasted, and so will be ok.)</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;2. The code blocks below are really pseudocode.  The include directives are put in there as guides.   Obviously, none of what is below constitutes the complete implementation of a simulation.  For that, see the examples that come with the library.</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;## Short version for the impatient</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;In this section, I define the _minimal_ requirements that a policy must conform to.  I also provide pseudocode in the form of lambda expressions in order to illustrate these requirements.  By &quot;requirements&#39;&#39;, I mean &quot;things that must be true, otherwise a program using __fwdpp__ will fail to compile.&#39;&#39;  Because __fwdpp__ is a template library, policy errors are caught at compile-time.  (Biological errors in your policies, however, will result in run-time issues.  For example, doing your fitness calculations incorrectly, etc.)  When policies require more than the minimal requirements described here, the programmer sends them along via either the usual &quot;bind&#39;&#39; mechanisms or via capature in lambda expressions.</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;I will describe the minimap policy requirements in terms of their equivalent declarations as objects of type [std::function](http://en.cppreference.com/w/cpp/utility/functional/function), which is a (variadic) C++11 template type that is used like this:</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;#include &lt;cmath&gt;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;#include &lt;functional&gt;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;//A function returning a double and taking two const double &amp; as arguments</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;std::function&lt; double(const double &amp;, const double &amp;) &gt; mypow = [](const double &amp; a, const double &amp; b) { return std::pow(a,b); };</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;//A function returning a double and taking three const double &amp; as arguments</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;std::function&lt; double(const double &amp;, const double &amp;,const double &amp;) &gt; mypow_over_x = [](const double &amp; a, const double &amp; b, const double &amp; c) { return std::pow(a,b)/c; };</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;//A function returning a double and taking a single const double &amp; as argument.  It is implemented in terms of a wrapper to the previous function.</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;std::function&lt;double(const double &amp;)&gt; mypow_over_x_wrapper = std::bind(mypow_over_x,3,2,std::placeholders::_1);</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;int main()</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;{</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  std::cout &lt;&lt; mypow(3,2) &lt;&lt; &#39;\n&#39;;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  for(unsigned i=1;i&lt;11;++i)</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      //These two calls will give the same result:</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      std::cout &lt;&lt; mypow_over_x(3,2,i) &lt;&lt; &#39; &#39; &lt;&lt;  mypow_over_x_wrapper(i) &lt;&lt; &#39;\n&#39;;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    }</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;}</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;~~~</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;So, std::function is a concrete type defining the _signature_ of a function (return type and arguments).  Internally, that signature must be met by your policies, and you can &quot;bind&quot; additional arguments to them in order to implement specific models.</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;For the sake of being explicit, let&#39;s assume that we are using the following types in an individual-based simulation (in C++11, &quot;using&#39;&#39; statements replace typedefs.):</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;using mtype = KTfwd::mutation;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;using mlist = std::list&lt;mtype&gt;;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;using gtype = KTfwd::gamete_base&lt;mtype&gt;;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;using glist = std::list&lt;gtype&gt;;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;~~~</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;A minimal mutation policy returns an __mtype__ and takes one of the following sets of arguments:</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;* A non-const reference to a &quot;recycling bin&quot; and a pointer to a mutation list</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;* A non-const reference to a &quot;recycling bin&quot;, a non-const reference to an iterator to a gemete and a pointer to a mutation list.</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;See KTfwd::infsites for examples of mutation policies.</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;When a gamete is mutated, we need to decide how to insert it into the __glist__.  This &quot;gamete insertion policy&#39;&#39; takes a const reference to an __gtype__ and a non-const pointer to an __glist__ as arguments, and returns an __glist::iterator__.  Again, under the infinitely-many sites model, a gamete with a new mutation is guaranteed to be unique, so we can simply insert it:</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;std::function&lt;glist::iterator(const gtype &amp;, glist *)&gt; gamete_insertion_policy = [](const gtype &amp; g,glist * __gametes) { </div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;return __gametes-&gt;insert(__gametes-&gt;end(),g); </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;};</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;~~~</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;A fitness policy takes two const references to __glist::const\_iterator__ as arguments and returns a double:</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;std::function&lt;double(const glist::const_iterator &amp;, const glist::const_iterator &amp;)&gt; fitness_policy = [&amp;](const glist::const_iterator &amp; __gamete1,</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;const glist::const_iterator &amp; __gamete2) {  </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  //No selection!</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  return 1.;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;}</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;~~~</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;See the header file __fwdpp/fitness\_models.hpp__ for examples of fitness policies that I provide for &quot;standard&#39;&#39; cases.</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;A recombination policy takes two non-const references to __glist::iterator__, scrambles up those gametes appropriately, and returns an unsigned integer representing the number of crossovers, etc., between the two gametes.  </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;Typically, recombination would work via a call to __KTfwd::recombine\_gametes__, or the convenience wrapper __KTfwd::genetics101__.  Here is an example of the latter, taken from the example file diploid_ind.cc:</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;std::bind(KTfwd::genetics101(),</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;   //These two placeholders are for  iterators to the two parental gametes</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;   std::placeholders::_1,std::placeholders::_2,</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;   //This placeholder is for a lookup table</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;   std::placeholders::_3,</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;   //This placeholder is for a &quot;recycling bin&quot;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   std::placeholders::_4,</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;   //These two containers should be allocated in main (or via the appropriate sugar type, _e.g._ KTfwd::singlepop_t)</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;   //They often need reference wrappers to make the templates compile.</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;   //They are used to hold the intermediate results of crossover events</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                   std::ref(neutral),std::ref(selected),</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                           &amp;pop.gametes,</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                                   littler,</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                                           r.get(),</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                                                   recmap)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;~~~</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;See @ref md_md_algo for more details about what the lookup table and the &quot;neutral&quot; and &quot;selected&quot; containers do.</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;For individual-based simulations with migration, returns an unsigned integer and takes on as an argument:</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;/*</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;Simple migration policy for two-deme simulation</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;*/</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;size_t migpop(const size_t &amp; source_pop, gsl_rng * r, const double &amp; mig_prob)</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;{</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  if( gsl_rng_uniform(r) &lt; mig_prob )</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    {</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      return ! source_pop;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  return source_pop;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;}</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;//Assume r and mig_prob are defined somewhere...</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;std::function&lt; unsigned(const unsigned &amp;) &gt; migpol = std::bind(migpop,std::placeholders::_1,r,mig_prob);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;~~~</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;## Technicalities related to policy &quot;types&quot;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;C++11 programmers will note that judicious use of &quot;auto&quot; will make all of the above code more streamlined.  Further, policies could be implemented in many cases as one or more of the following:</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;* functions</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;* function objects</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;* lambda expressions</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;* expressions synthesized from any of the above using std::bind</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;Further, the functions and function objects could themselves be implemented in terms of templates, meaning there are lots of ways to do things.</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;The use of std::function in the preceding section makes the return type and argument requirements explicit.  Further, it is often convenient to create policies by mixing std::bind and lambda expressions.  Let&#39;s revisit our previous C++ example:</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;~~~{.cpp} </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;#include &lt;cmath&gt;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;#include &lt;functional&gt;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;#include &lt;iostream&gt;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;auto mypow_over_x= [](const double &amp; a, const double &amp; b, const double &amp; c) { return std::pow(a,b)/c; };</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;auto mypow_over_x_wrapper1 = [&amp;](const double &amp; a, const double &amp; b, const double &amp; c) { return mypow_over_x(a,b,c); };</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;//This is the same as &quot;wrapper1&quot;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;auto mypow_over_x_wrapper2 = [&amp;](const double &amp; a, const double &amp; b, const double &amp; c) { return mypow_over_x(a,b,c); };</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;//These two are the same as wrappers 1 and 2...</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;std::function&lt;double(const double &amp;,const double &amp;, const double &amp;)&gt; mypow_over_x_wrapper3 = [&amp;](const double &amp; a, const double &amp; b, const double &amp; c) { return mypow_over_x(a,b,c); };</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;std::function&lt;double(const double &amp;,const double &amp;, const double &amp;)&gt; mypow_over_x_wrapper4 = [&amp;](const double &amp; a, const double &amp; b, const double &amp; c) { return mypow_over_x(a,b,c); };</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;int main()</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;{</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  //This will evaluate to 0!!!!</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  std::cout &lt;&lt; (typeid(mypow_over_x_wrapper1).name() == typeid(mypow_over_x_wrapper2).name()) &lt;&lt; &#39;\n&#39;;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  //This will evaluate to 1!!!!</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  std::cout &lt;&lt; (typeid(mypow_over_x_wrapper3).name() == typeid(mypow_over_x_wrapper4).name()) &lt;&lt; &#39;\n&#39;;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;}</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;~~~</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;The lesson: lambda expression __always__ have different signatures.  This matters for the metapopulation and multi-locus simulations where you must provide _vectors_ of policies, _e.g._:</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;//The only way to have a vector of policies is to force them to have the same signature (&quot;type&quot;):</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;std::vector&lt; std::function&lt; return_value( arg1_type, arg2_type, etc. )&gt; &gt; policies;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;~~~</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;\subsection TutMut Mutation policies</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;This is the mutation base class  provided by __fwdpp__</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  struct KTfwd::mutation_base</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  {</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    /// Mutation position</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    mutable double pos;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    /// Count of mutation in the population</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    unsigned n;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    /// Is the mutation neutral or not?</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    bool neutral;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    /// Used internally (don&#39;t worry about it for now...)</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    bool checked;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    mutation_base(const double &amp; position, </div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    const unsigned &amp; count, const bool &amp; isneutral = true)</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;      : pos(position),n(count),neutral(isneutral),checked(false)</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    {      </div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    }</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    virtual ~mutation_base(){}</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;};</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;~~~</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;The above code defines a mutation as something with a position (stored as a double), a count (unsigned integer), a boolean declaring the mutation to be neutral or not, and another boolean called &quot;checked&#39;&#39; which is very important but should only be directly manipulated by internal library functions (unless you really geek out and see what the internals are doing.  In that case--go nuts.)</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;The mutation base class is not sufficient for any interesting sorts of simulations.  Rather, one must derive a class from it with more data types.  The library provides a class called mutation, which is probably the standard type of mutation that a population geneticist would think of (this class is also in the library&#39;s namespace KTfwd):</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  struct mutation : public mutation_base</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  //!The simplest mutation type, adding just a selection </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  //coefficient and dominance to the interface</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    /// selection coefficient</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    mutable double s;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    /// dominance coefficient</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    mutable double h;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    mutation( const double &amp; position, const double &amp; sel_coeff,const unsigned &amp; count,</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;         const double &amp; dominance = 0.5) </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;      : mutation_base(position,count,(sel_coeff==0)),s(sel_coeff),h(dominance)</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    }</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    bool operator==(const mutation &amp; rhs) const</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      return( fabs(this-&gt;pos-rhs.pos) &lt;= std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;         this-&gt;s == rhs.s );</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    }</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;};</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;~~~</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;What does a mutation policy (model) need to do?  __The answer is that a single call to the mutation model function (or function object) must return a single instance of the simulation&#39;s mutation type with a count of 1.__</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;### Example: the infinitely-many sites model of mutation</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;This mutation model states that a new mutation occurs at a site not currently segregating in the population.  This statement implies the following:</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;1. We need a method to rapidly choose mutation positions that don&#39;t currently exist in the (meta-)population.</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;2. Each gamete containing a new mutation is by definition a new gamete in the (meta-)population.  If we did \#1 correctly, then the newly-mutated gamete differs from all others in the population by at least 1 new mutation.</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;We will now implement this mutation model for the mutation type &quot;mutation&#39;&#39; defined above.  In order to add some complexity to our mutation model, we will make the additional modeling assumptions:</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;1. Mutation positions are continuous on the interval \f$[0,1)\f$.</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;2. Neutral mutations arise at rate \f$\mu\f$ per gamete per generation</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;3. Selected mutations arise at rate \f$\mu_s\f$ per gamete per generation.</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;4. The selection coefficient for a newly-arising mutation is exponentially-distributed with mean \f$s_m\f$.  Further, half the time, selected mutations are deleterious (\f$s &lt; 0\f$).  Otherwise, they are beneficial (\f$s &gt; 0\f$).</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;5. Dominance will be uniform from 0 to 2.  (We&#39;ll be scaling fitness as \f$1, 1+hs, 1+2s\f$ for genotypes AA, Aa, and aa, respectively.)</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;From a programming point of view, we need a means to lookup all mutation positions currently segregating in the population.  __fwdpp__ provides support for lookup tables that conform to the behavior of the type __std::map__.  While one could use a type like </div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  std::map&lt;double,bool&gt;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;~~~</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;it is more efficient to use a hash table like </div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  #include &lt;unordered_set&gt; //need this header</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;  typedef std::unordered_set&lt;double,std::hash&lt;double&gt;,KTfwd::equal_eps &gt; lookup_table_type;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;~~~</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;The above code creates a new data type called __lookup\_table\_type__ that hashes doubles with the data type __KTfwd::equal\_eps__ as its comparison operator.  That comparison operation is provided by the library and looks like this:</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  struct equal_eps</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  {</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    typedef bool result_type;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    template&lt;typename T&gt;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    inline bool operator()(const T &amp; lhs, const T &amp; rhs) const</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      return( std::max(lhs,rhs)-std::min(lhs,rhs) &lt;= std::numeric_limits&lt;T&gt;::epsilon() );</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    }</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  };</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;~~~</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;Note that you could provide your own equality comparison policy for the hashing table.  This one would be excellent, and should be included in the library in future versions as it may be the most robust:</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  struct equality_comparison_strict</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  {</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    typedef bool result_type;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    template&lt;typename T&gt;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    inline bool operator()(const T &amp; lhs, const T &amp; rhs) const</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      return( !(lhs &gt; rhs) &amp;&amp; !(lhs &lt; rhs) );</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    }</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  };</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;~~~</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;We can now completely define our mutation model as a function (we could do it as a function object, too).  In this example, We assume that we are using the boost list type and boost&#39;s memory pool allocator:</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  typedef KTfwd::mutation mtype;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  typedef boost::pool_allocator&lt;mtype&gt; mut_allocator;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  typedef boost::container::list&lt;mtype,mut_allocator &gt; mlist;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  mtype mutmodel( gsl_rng * r,</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                  const double &amp; mu_neutral,</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                  const double &amp; mu_selected,</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                  const double &amp; mean_s,</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                  lookup_table_type * lookup )</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    {</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      //get new mutation position</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      double pos = gsl_rng_uniform(r);</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      //this is very rapid lookup...</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;      while( lookup-&gt;find(pos) != lookup-&gt;end() )</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;      {</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        pos = gsl_rng_uniform(r);</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      }</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;      //ok, we have new position, so put it in lookup table</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      lookup-&gt;insert(pos);</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;      //law of TTL prob</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      bool neutral = (gsl_rng_uniform(r) &lt; (mu_neutral)/(mu_neutral+mu_selected)) ? true : false;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;      //return neutral mutation</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;      if ( neutral ) { return mtype(pos,0,1,0); }</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;      //get selection coefficient</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      double s = gsl_ran_exponential(r,mean_s);</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;      if( gsl_ran_uniform(r) &lt;= 0.5 ) { s = -1.*s; }</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      //the gsl_ran_flat call generates the dominance</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      return mtype(pos,s,1,gsl_ran_flat(r,0.,2.));</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    }</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;~~~</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;That is is--the mutation model is complete.  We still need to deal with how mutations are entered into data structures representing the population, but we&#39;ll treat that later.</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;The mutation policy is passed to any of the various __KTfwd::sample\_diploid__ functions in the library like this:</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  std::bind(mutmodel,r, mu_neutral, mu_selected, mean_s, &amp;lookup);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;~~~</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;Or, using C++11 lambda expressions:</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  [&amp;](){ return mutmodel(r,mu_neutral, mu_selected,mean_s,&amp;lookup); }</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  ~~~</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;Note that both of the above declarations are the first of the four types of mutation moel alluded to above--they take no further arguments from the library&#39;s internals, and their signature is thus</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;std::function&lt;mtype(void)&gt;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;~~~</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;as far as the library is concerned.</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;Note that several of the data types passed to the model are non-const pointers.  Therefore, it is very likely that the data pointed to will be modified my the mutation model!</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;### A model for quantitative trait simulations</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;Let&#39;s define a model where a mutation affecting fitness does so via its effect size, \f$e\f$, which is Gaussian-distributed with mean zero and standard deviation \f$\sigma_e\f$.</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;We need a mutation class:</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  struct mut_e : public KTfwd::mutation_base</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  {</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    double e;</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    mut_e( const double &amp; __pos,</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;           const unsigned &amp; __n,</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;           const bool &amp; __neut,</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;           const double &amp; __e ) : KTfwd::mutation_base(__pos,__n,__neut),e(__e)</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;           {</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;           }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  };</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; typedef mut_e mtype;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;~~~</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;OK, our mutation model is going to be the following.  It is infinitely-many sites with both neutral and non-neutral mutations:</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;   typedef KTfwd::mutation mtype;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;   typedef boost::pool_allocator&lt;mtype&gt; mut_allocator;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;   typedef boost::container::list&lt;mtype,mut_allocator &gt; mlist;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;   mtype mutmodel_Qtrait( gsl_rng * r, mlist * mutations,</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                          const double &amp; mu_neutral,</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                          const double &amp; mu_selected,</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                          const double &amp; sigma_e,</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                          lookup_table_type * lookup )</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    {</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;      //get new mutation position</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      double pos = gsl_rng_uniform(r);</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;      //this is very rapid lookup...</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;      while( lookup-&gt;find(pos) != lookup-&gt;end() )</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;      {</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        pos = gsl_rng_uniform(r);</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;      }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;      //ok, we have new position, so put it in lookup table</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;      lookup-&gt;insert(pos);</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;      //law of TTL prob</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;      bool neutral = (gsl_rng_uniform(r) &lt; (mu_neutral)/(mu_neutral+mu_selected)) ? true : false;</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;      //return neutral mutation</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      if ( neutral ) { return mtype(pos,1,true,0); }</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;      //the gsl_ran_gaussian call determines the effect size</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      return mtype(pos,1,gsl_ran_gaussian(r,sigma_e),false);</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    }</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;~~~</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;\subsection TutRec Recombination</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;### How recombination is modeled in __fwdpp__</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;Currently, recombination is modeled as follows.  In a diploid, there number of crossovers between gametes is Poisson distributed with mean \f$r\f$.  There is no notion of interference in establishing crossover positions.  (However, that can be done with a clever policy.)</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;### Recombination map functions</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;In __fwdpp__, a recombination map is a function or function object that returns a double and takes no additional arguments from the algorithm.  The return value is the position of the crossing over event.  The simplest recombination map is uniform.  Here is how to implement such a map on the interval \f$[0,1)\f$:</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  #include &lt;functional&gt;</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  #include &lt;gsl/gls_rng.h&gt;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  //gsl_rng * r assumed to be initialized already...</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  std::function&lt; double(void) &gt; recmap = std::bind( gsl_rng_uniform, r);</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;~~~</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;Let us write a recombination map function that models a strong hotspot of crossing over.  The positions will still be on the interval \f$[0,1)\f$.  A fraction \f$p\f$ of the recombination events will come from a uniform distribution and \f$1-p\f$ will come from a beta distribution with parameters \f$a\f$ and \f$b\f$.  The genetic map looks like this:</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  double mixture_map(gsl_rng * r, </div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                     const double &amp; p,</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                     const double &amp; a,</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                     const double &amp; b)</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;      {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        return (gsl_rng_uniform(r) &lt; p) ? gsl_rng_uniform(r) : gsl_ran_beta(r,a,b);</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;      }</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  /*</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;     This is a hot hotspot.  say hist( c(runif(1e3),rbeta(9e3,100,100) ) ) in R </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;     to see density of crossover positions</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  */</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  std::function&lt; double(void) &gt; recmap = std::bind( mixture_map,r,0.1,100,100);</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;~~~</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;Either of the above code blocks results in a variable called recmap which is a function object representing a function call that takes no additional arguments and returns a double.  The variable recmap can be passed to the algorithm as the recombination (sometimes called genetic in the library documentation) map policy.</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;Note that the above policies were implemented by _synthesiszing_ a new function object type from a __std::bind__ operation via the __std::function__ template class.  You may synthesize all of your policies into variables this way, but it is not required.  However, the next subsection will reveal a case where it is required.</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;### Recombination model policy functions</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;Individual-based simulations require a recombination model policy.  This policy is a function/function object that takes two non-const references to iterators to gametes as arguments and returns an unsigned integer representing the number of crossovers between the two gametes.  (Note that the return value will never been seen by a library user.  It basically exists to help debug things deeper in the library if and when it comes to that.)  </div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;The library provides the policy __KTfwd::genetics101__ which implements the model of crossing over described above.</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;The policy looks like this:</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;     struct genetics101</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  /*! Genetics 101: simple model of recombination.  r is the probability that the two gametes recombine</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;   */</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  {</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    using result_type = unsigned;</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    template&lt;typename gamete_iterator_type,</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        typename gamete_list_type_allocator,</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        typename glookup_t,</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        template&lt;typename,typename&gt; class gamete_list_type,</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        typename rec_pos_generator&gt;</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    unsigned operator()( gamete_iterator_type &amp; g1,</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                    gamete_iterator_type &amp; g2,</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                    glookup_t &amp; gamete_lookup,</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                    typename gamete_iterator_type::value_type::mutation_container &amp; neutral,</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                    typename gamete_iterator_type::value_type::mutation_container &amp; selected,</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                    gamete_list_type&lt; typename gamete_iterator_type::value_type, gamete_list_type_allocator &gt; * gametes,</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                    const double &amp; littler,</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                    gsl_rng * r,</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                    const rec_pos_generator &amp; rp) const</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    {</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      unsigned NREC = 0;</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;      if( g1 != g2 )</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;   //then a non-parental type is inherited from p1 and p1 has two different gametes</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;   {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;     NREC += recombine_gametes(r,littler,gametes,g1,g2,gamete_lookup,neutral,selected,rp);</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;   }</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      return NREC;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    }</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  };</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;~~~</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;The main thing a library user needs to focus on is the argument list for __operator()__.  Specifically, it requires a variable of type __rec\_pos\_generator__ which is stated in the documentation to be a recombination map policy. Thus, a recombination model is a policy that requires another policy.  Further, __a recombination policy is passed non-const references to iterators to two gametes (g1 and g2 in the code above). Those iterators point to the parental gametes, and (as of fwdpp 0.3.3), they get &quot;swapped&#39; half to time to represent Mendelian segregation.  Ultimately, g1 represents the chromosome that will be passed on to the offspring, and the data that it points to will be modified by the library&#39;s internal functions for recombination.  See @ref md_md_algo for more details on how this works.  (The details of crossing over changed radically in version 0.3.3, resulting in much faster simulations.)</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;We pass this recombination model in an individual-based simulation to KTfwd::sample_diploid like this:</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;  using std::placeholders; //_1,_2, etc.</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;  std::bind(KTfwd::genetics101(),  //the rec. model</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;  _1,_2,                  //placeholder for iterators to gametes</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  _3, //placeholder for a lookup table</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;  std::ref(neutral),std::ref(selected), //containers for intermediate results</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;             &amp;gametes,               //pointer to gamete list</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;             littler,                //Avg. # of crossovers b/w two gametes per region per generation</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;             r,                      //a gsl_rng *</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;             recmap)                 //A genetic map policy like the one we made above</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;~~~</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;Note: if you want to write a new recombination policy, you probably want to proceed by modifying how it interacts with the the recombination map policy.  For example, if a recombination at position \f$x\f$ means that the next position must be \f$\geq 1.5x\f$ (in some model of interference).  Doing so requires making a custom version of the __KTfwd::recombine\_gametes__ function.  If you read the code for that function, you will see where the recombination map policy is called.  If you try to modify the code below that, then good luck to you.  It isn&#39;t super-complicated, but tread with caution.</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;\subsection TutMig Migration</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;Migration policies are only used in individual-based simulations.</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;For individual-based simulations involving a metapopulations, parent 1 comes from population \f$i\f$ and may or not be a migrant.  Parent two comes from population \f$j\f$ and \f$j = i\f$ in the case of no migration, otherwise \f$j \neq i\f$.  Migration policies may be the trickiest to write effectively because spatial models of migration can be complicated.  However, a migration policies requirements are simple.  A migration policy is a function or function object taking an argument if type size\_t and returning a value of type size\_t.  The argument is the index of population \f$i\f$, and the return value is the index of population \f$j\f$.</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;For example, let&#39;s assume two demes with migration rate \f$m\f$.  Here, \f$m\f$ is the probability that a parent is a migrant. This migration rate is equal between the two demes.  Because we are in a C-like language, the values allowed for the __size\_t__ are \f$0 \leq i \leq 1\f$.  The migration policy is thus defined as follows:</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;  size_t migpop(const size_t &amp; source_pop, gsl_rng * r, const double &amp; mig_prob)</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  {</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    //if parent is a migrant</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    if( gsl_rng_uniform(r) &lt; mig_prob )</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    {</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;      //return other population</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;      return ! source_pop;</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    }</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    //else, not a migrant</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    return source_pop;</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  }</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;~~~</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;And we pass it to __KTfwd::ample\_diploid__ like this:</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  std::bind(migpop, //the policy</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  std::placeholders::_1,     //placeholder for population index i</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  r,     //gsl_rng *</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  m)     //migration rate</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;~~~</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;\subsection TutFitness Fitness</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;The ability to define custom fitness policies is perhaps the most useful feature of __fwdpp__.  Broadly-speaking, there are two typical types of fitness models used in population genetics.  The first are what I call site-based models, such as the model of multipicative fitness across sites.  In this standard model, each non-neutral site is effectively its own gene. (A trans-heterozygotoe for two recessive mutations has wild-type fitness under the multiplicative assumption. That satisfies Benzer&#39;s definition of complementation, which is the operational definition of a gene.)  The second class are models are haplotype- or region- based, in that fitness depends on the effect sizes of the maternal and paternal haplotypes that a diploid inherited.  The library supports both types.  Haplotype-based fitness models are often efficient to compute, but site-based models can be done badly.  The library provides additional assistance for site-based models.</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;__A fitness policy is a function or function object taking two iterators pointing to gametes are arguments are returning a double.  The pointers are the diploid&#39;s haplotypes, and the return value is the fitness.__</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;### Site-dependent models of fitness</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;The library provides a fitness policy called __KTfwd::site\_dependent\_fitness__.  This function object requires two additional policies defining what to do with homozygous sites and heterozygous sites.  These &quot;homozygote&#39;&#39; and &quot;heterozygote&#39;&#39; policies may be trivially defined as lambda expressions:</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  struct multiplicative_diploid</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  {</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    typedef double result_type;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    template&lt; typename iterator_type&gt;</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    inline double operator()(const iterator_type &amp; g1, const iterator_type &amp; g2,</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                             const double scaling = 1.) const</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    {</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;      using __mtype = typename iterator_type::value_type::mutation_list_type_iterator;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;      return site_dependent_fitness()(g1,g2,</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;      //Homozygote policy</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                                 [&amp;](double &amp; fitness, const __mtype  &amp; mut)</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                                 {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                                   fitness *= (1. + scaling*mut-&gt;s);</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                                 },</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                                      //Heterozygote policy</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;                                 [](double &amp; fitness,const __mtype &amp; mut)</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                                 {</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                                   fitness *= (1. + mut-&gt;h*mut-&gt;s);</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                                 },</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                                      1.);</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    }</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  };</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;~~~</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;That last variable, scaling, means that fitness is the product of \f$1, 1+sh, 1+s \times \mathrm{scaling}\f$ over sites.  This allows you to recreate results from the different parts of the literature that use \f$scaling = 1\f$ and 2.  Many classic results are based on a scaling of 2.</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;To use the multiplicative fitness policy in your simulations, this goes to __KTfwd::sample\_diploid__:</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  std::bind(multiplicative_diploid(),std::placeholders::_1,std::placeholders::_2,2.)</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;~~~</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;If you wish to create your own site-dependent fitness policies, the recipe is:</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;1. Create your own versions of the policies determining what happens in diploids homozygous vs. heterozygous for a mutation.  __These policies are passed the current fitness from the algorithm and an iterator to a mutation object.__</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;2. Write a wrapper function like multiplicative\_diploid that passes these policies to __KTfwd::site_dependent_fitness__,  _which itself is a policy requiring that iterators to two gametes, the homozygote/heterozygote policies, and a starting value for fitness be passed to it._  In the example of the built-in multiplicative fitness policy, that value of \f$1\f$ that is passed as the last argument to __KTfwd::site\_dependent\_fitness__ is the initial value of fitness for a diploid.  In other words, \f$w = 1\f$ initially, and \f$w\f$ is then modified by the policies for what to do with homo- and hetero- zygous genotypes.</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;3. This wrapper function is your new fitness policy.</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;Note: the implementation  __KTfwd::site\_dependent\_fitness__ is a lot of iterator/pointer arithmetic.</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;### Haplotype based fitness policies</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;Here is one that assume a user-defined mutation type with effect size \f$e\f$ associated with it.  The effect of a haplotype is additive, the genetic model is recessive, and the phenotype is the genetic effect + a Gaussian random variable with standard deviation sigma.  Finally, fitnesses are under Gaussian stabilizing selection with a standard deviation of 1 and mean 0.</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;struct hapfitness</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;{</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  typedef result_type double;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  template&lt;typename gam_itr</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  double operator()(const gam_itr &amp; g1,</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;                    const gam_itr &amp; g2,</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                    gsl_rng * r,</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                    const double &amp; sigmaE) const</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;   {</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;     double sum1=0.,sum2=0.;</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;     typedef typename gam_itr::value_type::mutation_container::const_iterator mci;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;     for( mci mitr = g1.smutations.begin() ; mitr != g1.smutations.end() ; ++mitr )</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;     {</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;       //mitr is an iterator to an iterator!</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;       sum1 += (*mitr)-&gt;e;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;     }</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;     for( mci mitr = g2.smutations.begin() ; mitr != g2.smutations.end() ; ++mitr )</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;     {</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;       //mitr is an iterator to an iterator!</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;       sum2 += (*mitr)-&gt;e;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;     }</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;     //make sum1 be the value closest to 0</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;     if( fabs(sum1) &gt; fabs(sum2) ) { std::swap(sum1,sum2); }</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;     //add noise to fitness</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;     //Using sum1 as the genetic part makes the model recessive</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;     double pheno = sum1 + gsl_ran_gaussian(r,sigmaE);</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;     </div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;     /*</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;       Return fitnees under Gaussian stabilizing model.</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;       This is the only part of the Gaussian pdf that</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;       matters.  The rest is a constant</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;       and so won&#39;t affect sampling prop to fitness.</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;      */</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;     return std::exp( -std::pow(pheno,2) /2. );</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;   }</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;};</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;~~~</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;To use the above policy:</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;   std::bind( hapfitness(),</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        std::placeholders::_1,std::placeholders::_2,</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;   r,sigmaE );</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;~~~</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;Please note that a long-running annoyance with open-source C++ compilers (GCC!) is whether or not exp, pow, log, etc., are in namespace std or in the global namespace.  This can vary from version to version and across operating systems.  Sometimes, you need to say __std::exp__ when on another system that fails and you need __::exp__.</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;\subsection TutUpdateRemove Updating and removal policies</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;During the course of a simulation, new mutation and gamete types come and go.  New types must be entered in to their approproate containers.  The relevant policies are basically searches followed by either a member variable update or an insertion.  For example, consider our mutation model policy in section \ref{infsites}.  The mutation returned from that function is not currently found in our mutation list (because it has a unique position).  Therefore, the relevant policy is just to insert the new mutation at the end of the doubly-linked list of mutations.  Likewise, a gamete with a new mutation from that model cannot be identical to any currently-segregating gamete.  Therefore, a good policy is just to insert it at the end of the doubly-linked list of gametes.  However, a recombination event could make either a new gamete or a pre-existing gamete.  Thus, a policy to insert a recombinant gamete should do the following:</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;1. Figure out of the gamete is new or not.</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;2. If it is new, add it to the end of the gamete container.</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;3. It it is not new, do something intelligent, such as return the iterator to the pre-existing version of that gamete in the container.</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;These types of policies are simple.  See the header files __fwdpp/insertion\_policies.hpp__ and __fwdpp/fwd\_functional.hpp__. </div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;\section TutTieItup Putting it all togeter (kinda)</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;Ok, once we have defined our mutation types, our containers, and our policies, a single generation of a constant-sized population in an individual-based simulation is evolved a follows:</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  using std::placeholders; //_1,_2, etc.</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;  double wbar = KTfwd::sample_diploid(r,</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                                      &amp;gametes,  //non-const pointer to gametes</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                                      &amp;diploids, //non-const pointer to diploids</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                                      &amp;mutations, //non-const pointer to mutations</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                                      N,     //current pop size, remains constant</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                                      mu,    //mutation rate per gamete</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                                      /*</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                                      The mutation model (defined above) will pass each gamete</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                                            to be mutated to the mutation model function.  Again, _1</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;                                            is used as a placeholder for that gamete.</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                                          */</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                                          std::bind(mutmodel_Qtrait,r,_1,mu_neutral,mu_selected,sigma_e,&amp;lookup),</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                                  //The recombination policy includes the recombination map policy</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                                          std::bind(KTfwd::genetics101(),_1,_2,_3,_4,</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                                              &amp;gametes,</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                                                      littler,</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;                                                      r,</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                                                      recmap),</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                                  /*</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                                    Policy telling KTfwd::mutate how to add mutated gametes into the gamete pool.</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                                    If mutation results in a new gamete, add that gamete to the </div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                                    end of gametes. This is always the case under infinitely-many sites,</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;                                    but for other mutation models, mutation may result in a new</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                                    copy identical to an existing gamete.  If so,</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                                    that gamete&#39;s frequency increases by 1.</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                                  */</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                                          std::bind(KTfwd::insert_at_end&lt;gtype,glist&gt;,_1,_2),</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                                          std::bind(  std::bind( hapfitness(),</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                                                   _1,_2,</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                                                   r,sigmaE ),</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                                          /*</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                                         Only remove lost mutations</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                                          */</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                                          std::bind(KTfwd::mutation_remover(),_1,0));</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;          //Clean up the mutations list.  This also resets &quot;checked&#39;&#39; in each mutation to zero,</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;          //which is that &quot;internal detail&#39;&#39; referred to above</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;             KTfwd::update_mutations(&amp;mutations,&amp;lookup);</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;~~~</div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
