/*
  Expose fwdpp's most fundamental types to Python
  via the excellent pybind11 package: http://github.com/pybind/pybind11
*/

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <config.h> //fwdpp's config.h, which is auto-generated by that's packages ./configure
#include <fwdpp_python/include/fwdpp_python.hpp>

namespace py = pybind11;
using namespace KTfwd;

PYBIND11_PLUGIN(fwdpp_python)
{
  py::module m("fwdpp_python","Expose fwdpp types to Python.");

  m.def("version",
	[]()
	{
	  return PACKAGE_VERSION;
	},
	"Returns version number of this package, which is the same as the underlying version of fwdpp.");
  
  /*
    First, we do the main library:
    1. Mutation types
    2. Gamete types    

    Note: the data types are declared with read/write access
    to the Python environment!  This is potentially very dangerous!!!
    Also, performance implications should be explored...
  */

  py::class_<mutation_base>(m,"mutation_base","Base class for mutations.")
    .def_readwrite("pos",&mutation_base::pos)
    .def_readwrite("neutral",&mutation_base::neutral)
    ;
  
  py::class_<gamete>(m,"gamete","fwdpp's representation of a gamete.")
    .def_readwrite("n",&gamete::n,"The number of times this gamete exists.")
    .def_readwrite("mutations",&gamete::mutations,"Container of keys to mutations that **do not** affect fitness.")
    .def_readwrite("smutations",&gamete::smutations,"Container of keys to mutations that **do** affect fitness.")
    .def("as_dict",
	 [](const gamete & g) noexcept
	 {
	   py::dict rv;
	   using obj=py::object;
	   rv[obj(py::cast("n"))]=obj(py::cast(g.n));
	   rv[obj(py::cast("mutations"))]=obj(py::cast(g.mutations));
	   rv[obj(py::cast("smutations"))]=obj(py::cast(g.smutations));
	   return rv;
	 }
	 ,"Return a representation of this type as a dictionary."
	 )
    ;
    
  /*!
    Now, types from fwdpp's "sugar" layer
  */
  
  py::class_<popgenmut>(m,"popgenmut",py::base<mutation_base>(),"A mutation with an effect size and dominance.")
    .def(py::init<double,double,double,unsigned>(),
	 py::arg("pos"),py::arg("s"),
	 py::arg("g"),py::arg("generation"),
	 "Constructor.")
    .def_readwrite("s",&popgenmut::s,"Selection coefficient/effect size.")
    .def_readwrite("h",&popgenmut::h,"Dominance term.")
    .def_readwrite("g",&popgenmut::g,"Generation when this mutation arose.")
    .def("as_dict",
	 [](const popgenmut & p) noexcept
	 {
	   py::dict rv;
	   using obj=py::object;
	   rv[obj(py::cast("s"))]=obj(py::cast(p.s));
	   rv[obj(py::cast("h"))]=obj(py::cast(p.h));
	   rv[obj(py::cast("g"))]=obj(py::cast(p.g));
	   rv[obj(py::cast("pos"))]=obj(py::cast(p.pos));
	   rv[obj(py::cast("neutral"))]=obj(py::cast(p.neutral));
	   return rv;	   
	 }
	 ,"Return a representation of this type as a dictionary."
	 )
    ;

  //Types from include/fwdpp_python.hpp
  py::class_<fwdpp_python::GSLrng_t>(m,"GSLrng","A random number generator object.")
    .def(py::init<unsigned>(),py::arg("seed"))
    ;

  py::class_<fwdpp_python::diploid_t>(m,"diploid","Representation of a diploid.")
    .def_readwrite("first",&fwdpp_python::diploid_t::first,"First gamete.")
    .def_readwrite("second",&fwdpp_python::diploid_t::second,"Second gamete.")
    .def_readwrite("g",&fwdpp_python::diploid_t::g,"Genetic value. (Not assigned in all types of simulation.)")
    .def_readwrite("e",&fwdpp_python::diploid_t::e,"Non-genetic value. (Not assigned in all types of simulation.)")
    .def_readwrite("w",&fwdpp_python::diploid_t::e,"Fitness. (Not assigned in all types of simulation.)")
    .def("as_dict",
	 [](const fwdpp_python::diploid_t & dip) noexcept
	 {
	   py::dict rv;
	   using obj=py::object;
	   rv[obj(py::cast("first"))]=obj(py::cast(dip.first));
	   rv[obj(py::cast("second"))]=obj(py::cast(dip.second));
	   rv[obj(py::cast("g"))]=obj(py::cast(dip.g));
	   rv[obj(py::cast("e"))]=obj(py::cast(dip.e));
	   rv[obj(py::cast("w"))]=obj(py::cast(dip.w));
	   return rv;
	 },
    "Return a representation of this type as a dictionary.")
    ;

  py::class_<fwdpp_python::singlepop_t>(m,"singlepop","Object representing a single-deme, single-region simulation.")
    .def(py::init<unsigned>(),py::arg("N"),"Constructor takes a single argument, representing initial population size.")
    ;
    
  //Return module handle to Python environment
  return m.ptr();
}
