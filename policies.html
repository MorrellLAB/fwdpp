<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
</head>
<body>
<h1 id="policies-in-fwdpp">Policies in <strong>fwdpp</strong></h1>
<h2 id="introduction">Introduction</h2>
<p>This document is intended to be an in-depth discussion of policies and their role in implementing forward-time population genetic simulations using the C++ template library <strong>fwdpp</strong>. We will first describe what policies are using standard C++ examples, and then we will get into the harder stuff.</p>
<p>An understanding of C++ fundamentals, including containers, their iterators, and how they relate to the standard algorithms, is assumed knowledge here.</p>
<h2 id="policies-in-c">Policies in C++</h2>
<h3 id="policies-are-everywhere">Policies are everywhere</h3>
<p>Policies are a part of every programming language. Generally-speaking, they modify the behavior of what functions are with (or to) data. In other words, they turn a generic function into a piece of code doing a specific task. Let’s start with the rather trivial example of sorting a vector:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main ( <span class="dt">int</span> argc, <span class="dt">char</span> ** argv )
{
  vector&lt;<span class="dt">unsigned</span>&gt; vu{<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>};

  sort(vu.begin(),vu.end());
}</code></pre>
<p>The above example is 100% standard C++. But what is going on under the hood of the sort function is quite interesting. A bubble sort algorithm is being executed, and the values are being compared via a call to this function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt; <span class="kw">struct</span> less : binary_function &lt;T,T,<span class="dt">bool</span>&gt; {
    <span class="co">//algorithms can&#39;t guess return types,</span>
    <span class="co">//and therefore often need this typedef</span>
    <span class="kw">typedef</span> <span class="dt">bool</span> result_type;
    <span class="dt">bool</span> <span class="kw">operator</span>() (<span class="dt">const</span> T&amp; x, <span class="dt">const</span> T&amp; y) <span class="dt">const</span> {<span class="kw">return</span> x&lt;y;}
  };</code></pre>
<h3 id="policies-are-often-function-objects">Policies are often function objects</h3>
<p>The structure called less is a ``function object’’, and is the policy being employed in the bubble sort. Further, is a template, meaning it works on any data type for which <strong>operator&lt;</strong> is defined. The detail that less inherits from <strong>std::binary_function</strong> is important for how it plugs into the sort algorithm, but we’ll deal with those issues later.</p>
<p>The way such a function object is used looks like:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="dt">int</span> x = <span class="dv">5</span>, y = <span class="dv">6</span>;
  <span class="co">/*</span>
<span class="co">  The less() instantiates a (temporary) object of type less&lt;T&gt;,</span>
<span class="co">  where T = int in this case.</span>
<span class="co">  the (x,y) passes those to variables to the operator() of less.</span>
<span class="co">  (This is where the term</span>
<span class="co">  ``function object&#39;&#39;, or functor for short, comes from.)</span>
<span class="co">  */</span>
  <span class="dt">bool</span> x_is_less = less()(x,y);</code></pre>
<h3 id="policies-change-behavior-of-algorithms">Policies change behavior of algorithms</h3>
<p>OK, so now we hopefully have a basic understanding of what a policy is and that algorithms in C++ work through policies implemented as function objects. This lets us change the behavior of algorithms:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="ot">#include &lt;functional&gt; </span><span class="co">//need this header for std::greater&lt;T&gt;</span>
  <span class="co">//Sort in descending order (biggest values @ front of vu after sort)</span>
  sort( vu.begin(), vu.end(), greater&lt;<span class="dt">int</span>&gt;() );</code></pre>
<p>Same bubble sort, different outcome because of different policy.</p>
<h3 id="binding-extends-what-policies-can-do">Binding extends what policies can do</h3>
<p>We can further modify the behavior of policies by sending additional arguments along with the policy as it goes to the algorithm. This is called binding an argument to a function call. For example, let’s find the first value in our vector that is &gt;= 5:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="co">//we need these headers</span>
  <span class="ot">#include &lt;functional&gt;</span>
  <span class="ot">#include &lt;iostream&gt;</span>

  vector&lt;<span class="dt">unsigned</span>&gt;::iterator itr = find_if( vu.begin(), 
  vu.end(), 
  bind2nd( greater_equal&lt;<span class="dt">int</span>&gt;(), <span class="dv">5</span> ) );

  <span class="co">//print out the value pointed to by the iterator, </span>
  <span class="co">//if and only if we found something.  In C++,</span>
  <span class="co">//when a policy never finds anything, </span>
  <span class="co">//the end of the container is returned by tradition</span>
  <span class="kw">if</span>( itr != vu.end() )
  {
    cout &lt;&lt; *itr &lt;&lt; <span class="ch">&#39;\n&#39;</span>;
  }</code></pre>
<p>The find_if algorithm takes each value in the range and evaluates it via the policy. Here, the policy is greater_equal, which takes two arguments. The second argument is provided by using the standard-library function bind2nd, which results in the value 5 being the second value passed to the policy’s operator(). The new binders in C++11 are much better:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="co">//we need these headers</span>
  <span class="ot">#include &lt;functional&gt;</span>
  <span class="ot">#include &lt;iostream&gt;</span>

  vector&lt;<span class="dt">unsigned</span>&gt;::iterator itr = find_if( vu.begin(), 
  vu.end(), 
  <span class="co">//here, _1 is a placeholder for a value that the algorithm must provide</span>
  std::bind( greater_equal&lt;<span class="dt">int</span>&gt;(),std::placeholders::_1, <span class="dv">5</span> ) );

  <span class="co">//print out the value pointed to by the iterator, </span>
  <span class="co">//if and only if we found something.  In C++,</span>
  <span class="co">//when a policy never finds anything, </span>
  <span class="co">//the end of the container is returned by tradition</span>
  <span class="kw">if</span>( itr != vu.end() )
  {
    cout &lt;&lt; *itr &lt;&lt; <span class="ch">&#39;\n&#39;</span>;
  }</code></pre>
<h2 id="summary-so-far">Summary so far</h2>
<ul>
<li>Policies change how algorithms behave</li>
<li>Policies are often templates</li>
<li>Policies are often function objects</li>
<li>Policies + binders + algorithms = a reusable code base that can do lots of different (and often quite complicated) things when the right policy is written.</li>
<li>Policies can often be quite short to implement (see the definition of less above). This doesn’t have to be the case, but it often works out that way in practice.</li>
</ul>
<h1 id="algorithms-in-fwdpp">Algorithms in <strong>fwdpp</strong></h1>
<p>For individual-based simulations, the primary algorithms are <strong>KTfwd::sample_diploid</strong> and <strong>KTfwd::remove_lost</strong> and/or <strong>KTfwd::remove_fixed_lost</strong>. For gamete-baesd simulations, additional algorithms include the functions <strong>KTfwd::mutate</strong>, <strong>KTfwd::recombine</strong>, and <strong>KTfwd::migrate</strong> (and/or <strong>KTfwd::migrate_from_to</strong>). All of these functions are in the name space <strong>KTfwd</strong> and are documented both in the source code, via the doxygen output based on the source code, and finally in the example code that comes with the library.</p>
<p>Some of the code in some of these algorithms is quite complex, largely because generic templates can have hideous syntax. You should’t have to worry about that unless you like seeing how the sausage is made. Most users of <strong>fwdpp</strong> will be writing custom policies to stick into these algorithms and will likely be starting from the examples in order to get oriented. For them, the necessary information is to understand what is required of a policy. That is the subject of the remainder of this document.</p>
<h1 id="policy-requirements-in-fwdpp">Policy requirements in <strong>fwdpp</strong></h1>
<p>This section discusses the requirements placed on policies in <strong>fwdpp</strong>. These requirements are essentially standards placed on data types in order to ensure that simulations behave properly. (Note that <code>behave properly'' is not the same as</code>are implemented correctly’’! It is totally possible to have a simulation that compiles with no warnings and runs without crashing but is not the model you had in mind.) The policy requirements are enforced during compilation, such that a nonconforming policy cannot result in a compiled simulation program.</p>
<p>In the following sections, we will discuss policy requirements, how the built-in policies work, and also create some new policies. We’ll build some policies for a simple quantitative trait with selection simulation, and later on combine them all to see how <strong>KTfwd::sample_diploid</strong> would actually be called (for the case of a constant-sized population in an individual-based simulation). For additional and more complex examples, see the code for the example programs that come with the library.</p>
<p>Caveat emptor:</p>
<ol style="list-style-type: decimal">
<li>This document has been written ad lib, and there may be errors in the implementation of policies below. (The policies that are directly from the library have been copy/pasted, and so will be ok.)</li>
<li>The code blocks below are really pseudocode. The include directives are put in there are guides. Obviously, none of what is below constitutes the complete implementation of a simulation. For that, see the examples that come with the library.</li>
</ol>
<h2 id="short-version-for-the-impatient">Short version for the impatient</h2>
<p>In this section, I define the <em>minimal</em> requirements that a policy must conform to. I also provide pseudocode in the form of lambda expressions in order to illustrate these requirements. By <code>requirements'', I mean</code>things that must be true, otherwise a program using <strong>fwdpp</strong> will fail to compile.‘’ Because <strong>fwdpp</strong> is a template library, policy errors are caught at compile-time. (Biological errors in your policies, however, will result in run-time issues. For example, doing your fitness calculations incorrectly, etc.) When policies require more than the minimal requirements described here, the programmer sends them along via either the usual ``bind’’ mechanisms or via capature in lambda expressions.</p>
<p>The example program <strong>diploid_fixed_sh_lambda</strong> is an example of writing all policies using lambda expressions–take a look there for a concrete example of these concepts. The lambda expressions are very nice in that they document the policy requirements completely, as one is required to write them in the lambda arguments.</p>
<p>For the sake of this example, let’s assume that we are using the following types in an individual-based simulation (in C++11, ``using’’ statements replace typedefs.):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> mtype = KTfwd::mutation;
<span class="kw">using</span> mlist = std::list&lt;mtype&gt;;
<span class="kw">using</span> gtype = KTfwd::gamete_base&lt;mtype&gt;;
<span class="kw">using</span> glist = std::list&lt;gtype&gt;;</code></pre>
<p>A minimal mutation policy takes a non-const pointer to an <strong>mlist</strong> as an argument, and returns an <strong>mtype</strong>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//the [&amp;] is used to capture any things that may be needed</span>
<span class="dt">auto</span> mut_policy = [&amp;](mlist * __mutations){ <span class="kw">return</span> function_generating_new_type( arguments ); };</code></pre>
<p>We then need to decide how to add a new mutation (the return value of the mutation policy) to the list of mutations. This ``mutation insertion policy’’ takes a const reference to an <strong>mtype</strong> and a non-const pointer to an <strong>mlist</strong> as arguments, and returns an <strong>mlist::iterator</strong>. This is an example for the infinite-sites model. Under this model, we know that a new mutation is at a new position, therefore we simply insert it at the end of the mlist:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">auto</span> mut_insertion_policy = [](<span class="dt">const</span> mtype &amp; m,mlist * __mutations) { 
<span class="kw">return</span> __mutations-&gt;insert(__mutations-&gt;end(),m); 
};</code></pre>
<p>When a gamete is mutated, we need to decide how to insert it into the <strong>glist</strong>. This ``gamete insertion policy’’ takes a const reference to an <strong>gtype</strong> and a non-const pointer to an <strong>glist</strong> as arguments, and returns an <strong>glist::iterator</strong>. Again, under the infinitely-many sites model, a gamete with a new mutation is guaranteed to be unique, so we can simply insert it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">auto</span> gamete_insertion_policy = [](<span class="dt">const</span> gtype &amp; g,glist * __gametes) { 
<span class="kw">return</span> __gametes-&gt;insert(__gametes-&gt;end(),g); 
};</code></pre>
<p>A fitness policy takes two const references to <strong>glist::const_iterator</strong> as arguments and returns a double:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">auto</span> fitness_policy = [&amp;](<span class="dt">const</span> glist::const_iterator &amp; __gamete1,
<span class="dt">const</span> glist::const_iterator &amp; __gamete2) {
  <span class="co">//No selection!</span>
  <span class="kw">return</span> <span class="dv">1</span>.;
}</code></pre>
<p>See the header file <strong>fwdpp/fitness_models.hpp</strong> for examples of fitness policies that I provide for ``standard’’ cases.</p>
<p>A recombination policy takes two non-const references to <strong>glist::iterator</strong>, scrambles up those gametes appropriately, and returns an unsigned integer representing the number of crossovers, etc., between the two gametes. Typically, this would work via a call to <strong>KTfwd::recombine_gametes</strong>, or the convenience wrapper <strong>KTfwd::genetics101</strong>. Here is an example of the former, where the genetic map is uniform on the interval <span class="math">(0, 1]</span>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//These parameters will be captuered by reference ([&amp;] in the lambda </span>
<span class="co">//expression below), because their state will be modified</span>
gsl_rng * r;
glist gametes;
<span class="co">//littler is the recombination rate per diploid per generation</span>
<span class="dt">auto</span> rec_policy =  [&amp;](glist::iterator &amp; g1,
glist::iterator &amp; g2) { <span class="kw">return</span> KTfwd::recombine_gametes(r,littler,&amp;gametes,g1,g2,
  <span class="co">//This nested lambda is our genetic map: uniform on interval (0,1]</span>
  [&amp;](){<span class="kw">return</span> gsl_rng_uniform(r);}); },</code></pre>
<p>I’ll document migration policy functions at a later date, sorry.</p>
<h2 id="mutation-policies">Mutation policies</h2>
<p>This is the mutation base class provided by <strong>fwdpp</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="co">/*! </span><span class="kw">\brief</span><span class="co"> Base class for mutations</span>
<span class="co">    At minimum, a mutation must contain a position and a count in the population.   </span>
<span class="co">    You can derive from this class, for instance to add selection coefficients,</span>
<span class="co">    counts in different sexes, etc.</span>
<span class="co">  */</span>
  <span class="kw">struct</span> KTfwd::mutation_base
  {
    <span class="co">/// Mutation position</span>
    <span class="dt">mutable</span> <span class="dt">double</span> pos;
    <span class="co">/// Count of mutation in the population</span>
    <span class="dt">unsigned</span> n;
    <span class="co">/// Is the mutation neutral or not?</span>
    <span class="dt">bool</span> neutral;
    <span class="co">/// Used internally (don&#39;t worry about it for now...)</span>
    <span class="dt">bool</span> checked;
    mutation_base(<span class="dt">const</span> <span class="dt">double</span> &amp; position, 
    <span class="dt">const</span> <span class="dt">unsigned</span> &amp; count, <span class="dt">const</span> <span class="dt">bool</span> &amp; isneutral = <span class="kw">true</span>)
      : pos(position),n(count),neutral(isneutral),checked(<span class="kw">false</span>)
    {   
    }
    <span class="kw">virtual</span> ~mutation_base(){}
};</code></pre>
<p>The above code defines a mutation as something with a position (stored as a double), a count (unsigned integer), a boolean declaring the mutation to be neutral or not, and another boolean called ``checked’’ which is very important but should only be directly manipulated by internal library functions (unless you really geek out and see what the internals are doing. In that case–go nuts.)</p>
<p>The mutation base class is not sufficient for any interesting sorts of simulations. Rather, one must derive a class from it with more data types. The library provides a class called mutation, which is probably the standard type of mutation that a population geneticist would think of (this class is also in the library’s namespace KTfwd):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">struct</span> mutation : <span class="kw">public</span> mutation_base
  <span class="co">//!The simplest mutation type, adding just a selection </span>
  <span class="co">//coefficient and dominance to the interface</span>
  {
    <span class="co">/// selection coefficient</span>
    <span class="dt">mutable</span> <span class="dt">double</span> s;
    <span class="co">/// dominance coefficient</span>
    <span class="dt">mutable</span> <span class="dt">double</span> h;
    mutation( <span class="dt">const</span> <span class="dt">double</span> &amp; position, <span class="dt">const</span> <span class="dt">double</span> &amp; sel_coeff,<span class="dt">const</span> <span class="dt">unsigned</span> &amp; count,
          <span class="dt">const</span> <span class="dt">double</span> &amp; dominance = <span class="fl">0.5</span>) 
      : mutation_base(position,count,(sel_coeff==<span class="dv">0</span>)),s(sel_coeff),h(dominance)
    {
    }
    <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> mutation &amp; rhs) <span class="dt">const</span>
    {
      <span class="kw">return</span>( fabs(<span class="kw">this</span>-&gt;pos-rhs.pos) &lt;= std::numeric_limits&lt;<span class="dt">double</span>&gt;::epsilon() &amp;&amp;
          <span class="kw">this</span>-&gt;s == rhs.s );
    }
};</code></pre>
<p>What does a mutation policy (model) need to do? <strong>{The answer is that a single call to the mutation model function (or function object) must return a single instance of the simulation’s mutation type with a count of 1.</strong></p>
<h3 id="example-the-infinitely-many-sites-model-of-mutation">Example: the infinitely-many sites model of mutation</h3>
<p>This mutation model states that a new mutation occurs at a site not currently segregatig in the population. This statement implies the following:</p>
<ol style="list-style-type: decimal">
<li>We need a method to rapidly choose mutation positions that don’t currently exist in the (meta-)population.</li>
<li>Each gamete containing a new mutation is by definition a new gamete in the (meta-)population. If we did #1 correctly, then the newly-mutated gamete differs from all others in the population by at least 1 new mutation.</li>
</ol>
<p>We will now implement this mutation model for the mutation type ``mutation’’ defined above. In order to add some complexity to our mutation model, we will make the additional modeling assumptions:</p>
<ol style="list-style-type: decimal">
<li>Mutation positions are continuous on the interval <span class="math">[0, 1)</span>.</li>
<li>Neutral mutations arise at rate <span class="math"><em>μ</em></span> per gamete per generation</li>
<li>Selected mutations arise at rate <span class="math"><em>μ</em><sub><em>s</em></sub></span> per gamete per generation.</li>
<li>The selection coefficient for a newly-arising mutation is exponentially-distributed with mean <span class="math"><em>s</em><sub><em>m</em></sub></span>. Further, half the time, selected mutations are deleterious (<span class="math"><em>s</em> &lt; 0</span>). Otherwise, they are beneficial (<span class="math"><em>s</em> &gt; 0</span>).</li>
<li>Dominance will be uniform from 0 to 2. (We’ll be scaling fitness as <span class="math">1, 1 + <em>h</em><em>s</em>, 1 + 2<em>s</em></span> for genotypes AA, Aa, and aa, respectively.)</li>
</ol>
<p>From a programming point of view, we need a means to lookup all mutation positions currently segregating in the population. <strong>fwdpp</strong> provides support for lookup tables that conform to the behavior of the type <strong>std::map</strong>. While one could use a type like</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  std::map&lt;<span class="dt">double</span>,<span class="dt">bool</span>&gt;</code></pre>
<p>it is more efficient to use a hash table like</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="ot">#include &lt;unordered_set&gt; </span><span class="co">//need this header</span>
  <span class="kw">typedef</span> std::unordered_set&lt;<span class="dt">double</span>,std::hash&lt;<span class="dt">double</span>&gt;,KTfwd::equal_eps &gt; lookup_table_type;</code></pre>
<p>The above code creates a new data type called <strong>lookup_table_type</strong> that hashes doubles with the data type <strong>KTfwd::equal_eps</strong> as its comparison operator. That comparison operation is provided by the library and looks like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">struct</span> equal_eps
  {
    <span class="kw">typedef</span> <span class="dt">bool</span> result_type;
    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>()(<span class="dt">const</span> T &amp; lhs, <span class="dt">const</span> T &amp; rhs) <span class="dt">const</span>
    {
      <span class="kw">return</span>( std::max(lhs,rhs)-std::min(lhs,rhs) &lt;= std::numeric_limits&lt;T&gt;::epsilon() );
    }
  };</code></pre>
<p>Note that you could provide your own equality comparison policy for the hashing table. This one would be excellent, and should be included int the library in future versions as it may be the most robust:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">struct</span> equality_comparison_strict
  {
    <span class="kw">typedef</span> <span class="dt">bool</span> result_type;
    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>()(<span class="dt">const</span> T &amp; lhs, <span class="dt">const</span> T &amp; rhs) <span class="dt">const</span>
    {
      <span class="kw">return</span>( !(lhs &gt; rhs) &amp;&amp; !(lhs &lt; rhs) );
    }
  };</code></pre>
<p>We can now completely define our mutation model as a function (we could do it as a function object, too). In this example, We assume that we are using the boost list type and boost’s memory pool allocator:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">typedef</span> KTfwd::mutation mtype;
  <span class="kw">typedef</span> boost::pool_allocator&lt;mtype&gt; mut_allocator;
  <span class="kw">typedef</span> boost::container::list&lt;mtype,mut_allocator &gt; mlist;
  mtype mutmodel( gsl_rng * r, mlist * mutations,
                  <span class="dt">const</span> <span class="dt">double</span> &amp; mu_neutral,
                  <span class="dt">const</span> <span class="dt">double</span> &amp; mu_selected,
                  <span class="dt">const</span> <span class="dt">double</span> &amp; mean_s,
                  lookup_table_type * lookup )
    {
      <span class="co">//get new mutation position</span>
      <span class="dt">double</span> pos = gsl_rng_uniform(r);
      <span class="co">//this is very rapid lookup...</span>
      <span class="kw">while</span>( lookup-&gt;find(pos) != lookup-&gt;end() )
      {
        pos = gsl_rng_uniform(r);
      }
      <span class="co">//ok, we have new position, so put it in lookup table</span>
      lookup-&gt;insert(pos);

      <span class="co">//law of TTL prob</span>
      <span class="dt">bool</span> neutral = (gsl_rng_uniform(r) &lt;= (mu_neutral)/(mu_neutral+mu_selected)) ? <span class="kw">true</span> : <span class="kw">false</span>;

      <span class="co">//return neutral mutation</span>
      <span class="kw">if</span> ( neutral ) { <span class="kw">return</span> mtype(pos,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>); }

      <span class="co">//get selection coefficient</span>
      <span class="dt">double</span> s = gsl_ran_exponential(r,mean_s);
      <span class="kw">if</span>( gsl_ran_uniform(r) &lt;= <span class="fl">0.5</span> ) { s = -<span class="dv">1</span>.*s; }

      <span class="co">//the gsl_ran_flat call generates the dominance</span>
      <span class="kw">return</span> mtype(pos,s,<span class="dv">1</span>,gsl_ran_flat(r,<span class="dv">0</span>.,<span class="dv">2</span>.));
    }</code></pre>
<p>That is is–the mutation model is complete. We still need to deal with how mutations are entered into data structures representing the population, but we’ll treat that later.</p>
<p>The mutation policy is passed to any of the various <strong>KTfwd::sample_diploid</strong> functions in the library like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  std::bind(mutmodel,r,&amp;mutations,
  mu_neutral, mu_selected,
  mean_s, &amp;lookup);</code></pre>
<p>Or, using C++11 lambda expressions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  [&amp;](mlist * __mutations){ <span class="kw">return</span> mutmodel(r,__mutations,mu_neutral,
    mu_selected,mean_s,&amp;lookup); }</code></pre>
<p>Note that several of the data types passed to the model are non-const pointers. Therefore, it is very likely that the data pointed to will be modified my the mutation model!</p>
<h3 id="a-model-for-quantitative-trait-simulations">A model for quantitative trait simulations</h3>
<p>Let’s define a model where a mutation affecting fitness does so via its effect size, <span class="math"><em>e</em></span>, which is Gaussian-distributed with mean zero and standard deviation <span class="math"><em>σ</em><sub><em>e</em></sub></span>.</p>
<p>We need a mutation class:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">struct</span> mut_e : <span class="kw">public</span> KTfwd::mutation_base
  {
    <span class="dt">double</span> e;
    mut_e( <span class="dt">const</span> <span class="dt">double</span> &amp; __pos,
           <span class="dt">const</span> <span class="dt">unsigned</span> &amp; __n,
           <span class="dt">const</span> <span class="dt">bool</span> &amp; __neut,
           <span class="dt">const</span> <span class="dt">double</span> &amp; __e ) : KTfwd::mutation_base(__pos,__n,__neut),e(__e)
           {
           }
  };

 <span class="kw">typedef</span> mut_e mtype;</code></pre>
<p>OK, our mutation model is going to be the following. It is infinitely-many sites with both neutral and non-neutral mutations:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">   <span class="kw">typedef</span> KTfwd::mutation mtype;
   <span class="kw">typedef</span> boost::pool_allocator&lt;mtype&gt; mut_allocator;
   <span class="kw">typedef</span> boost::container::list&lt;mtype,mut_allocator &gt; mlist;
   mtype mutmodel_Qtrait( gsl_rng * r, mlist * mutations,
                          <span class="dt">const</span> <span class="dt">double</span> &amp; mu_neutral,
                          <span class="dt">const</span> <span class="dt">double</span> &amp; mu_selected,
                          <span class="dt">const</span> <span class="dt">double</span> &amp; sigma_e,
                          lookup_table_type * lookup )
    {
      <span class="co">//get new mutation position</span>
      <span class="dt">double</span> pos = gsl_rng_uniform(r);
      <span class="co">//this is very rapid lookup...</span>
      <span class="kw">while</span>( lookup-&gt;find(pos) != lookup-&gt;end() )
      {
        pos = gsl_rng_uniform(r);
      }
      <span class="co">//ok, we have new position, so put it in lookup table</span>
      lookup-&gt;insert(pos);

      <span class="co">//law of TTL prob</span>
      <span class="dt">bool</span> neutral = (gsl_rng_uniform(r) &lt;= (mu_neutral)/(mu_neutral+mu_selected)) ? <span class="kw">true</span> : <span class="kw">false</span>;

      <span class="co">//return neutral mutation</span>
      <span class="kw">if</span> ( neutral ) { <span class="kw">return</span> mtype(pos,<span class="dv">1</span>,<span class="kw">true</span>,<span class="dv">0</span>); }

      <span class="co">//the gsl_ran_gaussian call determines the effect size</span>
      <span class="kw">return</span> mtype(pos,<span class="dv">1</span>,gsl_ran_gaussian(r,sigma_e),<span class="kw">false</span>);
    }</code></pre>
<h2 id="recombination">Recombination</h2>
<h3 id="how-recombination-is-modeled-in-fwdpp">How recombination is modeled in <strong>fwdpp</strong></h3>
<p>Currently, recombination is modeled as follows. In a diploid, there number of crossovers between gametes is Poisson distributed with mean <span class="math"><em>r</em></span>. There is no notion of interference in establishing crossover positions. (However, that can be done with a clever policy.)</p>
<p>Note: what I describe as <span class="math"><em>r</em></span> above is the usual definition in population genetics. However, gamete-based simulations (confusingly, I admit) use r/2, because the per-generation r is used to determine how many recombination events a gamete is involved in. In other words, it is treated as a “per-gamete’‘parameter. There is more detail on this in the main library documentation, and you’ll see in the example simulations that I divide <span class="math"><em>ρ</em></span> (the population-scaled rate of recombination) by <span class="math">8<em>N</em></span> to get ``littler’’ rather than the more common <span class="math">4<em>N</em></span>. (Again, to be clear, <span class="math"><em>r</em> = <em>ρ</em> / 4<em>N</em></span> for individual-based simulations.)</p>
<h3 id="recombination-map-functions">Recombination map functions</h3>
<p>In <strong>fwdpp</strong>, a recombination map is a function or function object that returns a double and takes no additional arguments from the algorithm. The return value is the position of the crossing over event. The simplest recombination map is uniform. Here is how to implement such a map on the interval <span class="math">[0, 1)</span>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="ot">#include &lt;functional&gt;</span>
  <span class="ot">#include &lt;gsl/gls_rng.h&gt;</span>
  <span class="co">//gsl_rng * r assumed to be initialized already...</span>
  std::function&lt; <span class="dt">double</span>(<span class="dt">void</span>) &gt; recmap = std::bind( gsl_rng_uniform, r);</code></pre>
<p>Let us write a recombination map function that models a strong hotspot of crossing over. The positions will still be on the interval <span class="math">[0, 1)</span>. A fraction <span class="math"><em>p</em></span> of the recombination events will come from a uniform distribution and <span class="math">1 − <em>p</em></span> will come from a beta distribution with parameters <span class="math"><em>a</em></span> and <span class="math"><em>b</em></span>. The genetic map looks like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="dt">double</span> mixture_map(gsl_rng * r, 
                     <span class="dt">const</span> <span class="dt">double</span> &amp; p,
                     <span class="dt">const</span> <span class="dt">double</span> &amp; a,
                     <span class="dt">const</span> <span class="dt">double</span> &amp; b)
      {
        <span class="kw">return</span> (gsl_rng_uniform(r) &lt;= p) ? gsl_rng_uniform(r) : gsl_ran_beta(r,a,b);
      }
  <span class="co">/*</span>
<span class="co">     This is a hot hotspot.  say hist( c(runif(1e3),rbeta(9e3,100,100) ) ) in R </span>
<span class="co">     to see density of crossover positions</span>
<span class="co">  */</span>
  std::function&lt; <span class="dt">double</span>(<span class="dt">void</span>) &gt; recmap = std::bind( mixture_map,r,<span class="fl">0.1</span>,<span class="dv">100</span>,<span class="dv">100</span>);</code></pre>
<p>Either of the above code blocks results in a variable called recmap which is a function object representing a function call that takes no additional arguments and returns a double. The variable recmap can be passed to the algorithm as the recombination (sometimes called genetic in the library documentation) map policy.</p>
<p>Note that the above policies were implemented by <em>synthesiszing</em> a new function object type from a stdd::bind operation via the std::function template class. You may synthesize all of your policies into variables this way, but it is not required. However, the next subsection will reveal a case where it is required.</p>
<p>Note that gamete-based simulations only require this policy.</p>
<h3 id="recombination-model-policy-functions">Recombination model policy functions</h3>
<p>Individual-based simulations require a recombination model policy. This policy is a function/function object that takes two non-const references to iterators to gametes as arguments and returns an unsigned integer representing the number of crossovers between the two gametes. (Note that the return value will never been seen by a library user. It basically exists to help debug things deeper in the library if and when it comes to that.)</p>
<p>The library provides the policy <strong>KTfwd::genetics101</strong> which implements the model of crossing over described above.</p>
<p>The policy looks like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">struct</span> genetics101
  {
    <span class="kw">typedef</span> <span class="dt">unsigned</span> result_type;
    <span class="kw">template</span>&lt;<span class="kw">typename</span> gamete_iterator_type,
             <span class="kw">typename</span> gamete_list_type_allocator,
             <span class="kw">template</span>&lt;<span class="kw">typename</span>,<span class="kw">typename</span>&gt; <span class="kw">class</span> gamete_list_type,
             <span class="kw">typename</span> rec_pos_generator&gt;
    <span class="dt">unsigned</span> <span class="kw">operator</span>()( gamete_iterator_type &amp; g1,
                         gamete_iterator_type &amp; g2,
                         gamete_list_type&lt; <span class="kw">typename</span> gamete_iterator_type::value_type,
                                           gamete_list_type_allocator &gt; * gametes,
                                           <span class="dt">const</span> <span class="dt">double</span> &amp; littler,
                                           gsl_rng * r,
                                           <span class="dt">const</span> rec_pos_generator &amp; rp) <span class="dt">const</span>
       {
         <span class="kw">typedef</span> gamete_list_type&lt; <span class="kw">typename</span> gamete_iterator_type::value_type, 
                                   gamete_list_type_allocator &gt; glist_t;
         <span class="dt">unsigned</span> NREC = <span class="dv">0</span>;
         <span class="kw">if</span>( g1 != g2 &amp;&amp; gsl_rng_uniform(r) &lt;= <span class="fl">0.5</span> )
         <span class="co">//then a non-parental type is inherited from p1 and p1 has two different gametes                                    </span>
         {
           NREC += recombine_gametes(r,littler,gametes,g1,g2,rp,
           std::bind(update_if_exists_insert&lt;<span class="kw">typename</span> gamete_iterator_type::value_type,glist_t&gt;,
           std::placeholders::_1,gametes));
         }
         <span class="kw">return</span> NREC;
       }
     };</code></pre>
<p>The main thing a library user needs to focus on is the argument list for <strong>operator()</strong>. Specifically, it requires a variable of type <strong>rec_pos_generator</strong> which is stated in the documentation to be a recombination map policy. Thus, a recombination model is a policy that requires another policy. Further, <strong>a recombination policy is passed non-const references to iterators to two gametes (g1 and g2 in the code above). Those iterators are updated in place. In the event of no recombination, g1 and g2 remain unchanged. Otherwise, g1 and g2 are modified to point to the new recombinants, which are new gametes inersted into the population at a count of 1.</strong></p>
<p>We pass this recombination model in an individual-based simulation to <strong>KTfwd::sample_diploid</strong> like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">using</span> std::placeholders; <span class="co">//_1,_2, etc.</span>
  std::bind(KTfwd::genetics101(),  <span class="co">//the rec. model</span>
             _1,_2,                  <span class="co">//placeholder for iterators to gametes</span>
             &amp;gametes,               <span class="co">//pointer to gamete list</span>
             littler,                <span class="co">//Avg. # of crossovers b/w two gametes per region per generation</span>
             r,                      <span class="co">//a gsl_rng *</span>
             recmap)                 <span class="co">//A genetic map policy like the one we made above</span></code></pre>
<p>Note: if you want to write a new recombination policy, you probably want to proceed by modifying how it interacts with the the recombination map policy. For example, if a recombination at position <span class="math"><em>x</em></span> means that the next position must be <span class="math"> ≥ 1. 5<em>x</em></span> (in some model of interference). Doing so requires making a custom version of the <strong>KTfwd::recombine_gametes</strong> function. If you read the code for that function, you will see where the recombination map policy is called. If you try to modify the code below that, then good luck to you. It isn’t super-complicated, but tread with caution.</p>
<h2 id="migration">Migration</h2>
<p>Migration policies are only used in individual-based simulations. For gamete-based simulations, you may write a migration function (replacing <strong>KTfwd::migrate</strong>) that does what you need it to and is implemented in terms of <strong>KTfwdd::migrate_from_to</strong>.</p>
<p>For individual-based simulations involving a metapopulations, parent 1 comes from population <span class="math"><em>i</em></span> and may or not be a migrant. Parent two comes from population <span class="math"><em>j</em></span> and <span class="math"><em>j</em> = <em>i</em></span> in the case of no migration, otherwise <span class="math"><em>j</em> ≠ <em>i</em></span>. Migration policies may be the trickiest to write effectively because spatial models of migration can be complicated. However, a migration policies requirements are simple. <strong>A migration policy is a function or function object taking an argument if type size_t and returning a value of type size_t. The argument is the index of population <span class="math"><em>i</em></span>, and the return value is the index of population <span class="math"><em>j</em></span>.</strong></p>
<p>For example, let’s assume two demes with migration rate <span class="math"><em>m</em></span>. Here, <span class="math"><em>m</em></span> is the probability that a parent is a migrant. This migration rate is equal between the two demes. Because we are in a C-like language, the values allowed for the <strong>size_t</strong> are <span class="math">0 ≤ <em>i</em> ≤ 1</span>. The migration policy is thus defined as follows:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  size_t migpop(<span class="dt">const</span> size_t &amp; source_pop, gsl_rng * r, <span class="dt">const</span> <span class="dt">double</span> &amp; mig_prob)
  {
    <span class="co">//if parent is a migrant</span>
    <span class="kw">if</span>( gsl_rng_uniform(r) &lt;= mig_prob )
    {
      <span class="co">//return other population</span>
      <span class="kw">return</span> ! source_pop;
    }
    <span class="co">//else, not a migrant</span>
    <span class="kw">return</span> source_pop;
  }</code></pre>
<p>And we pass it to <strong>KTfwd::ample_diploid</strong> like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  std::bind(migpop, <span class="co">//the policy</span>
  std::placeholders::_1,     <span class="co">//placeholder for population index i</span>
  r,     <span class="co">//gsl_rng *</span>
  m)     <span class="co">//migration rate</span></code></pre>
<h1 id="fitness">Fitness</h1>
<p>The ability to define custom fitness policies is perhaps the most useful feature of <strong>fwdpp</strong>. Broadly-speaking, there are two typical types of fitness models used in population genetics. The first are what I call site-based models, such as the model of multipicative fitness across sites. In this standard model, each non-neutral site is effectively its own gene. (A trans-heterozygotoe for two recessive mutations has wild-type fitness under the multiplicative assumption. That satisfies Benzer’s definition of complementation, which is the operational definition of a gene.) The second class are models are haplotype- or region- based, in that fitness depends on the effect sizes of the maternal and paternal haplotypes that a diploid inherited. The library supports both types. Haplotype-based fitness models are often efficient to compute, but site-based models can be done badly. The library provides additional assistance for site-based models.</p>
<p><strong>A fitness policy is a function or function object taking two iterators pointing to gametes are arguments are returning a double. The pointers are the diploid’s haplotypes, and the return value is the fitness.</strong> ##Site-dependent models of fitness</p>
<p>The library provides a fitness policy called <strong>KTfwd::site_dependent_fitness</strong>. This function object requires two additional policies defining what to do with homozygous sites and heterozygous sites. These <code>homozygote'' and</code>heterozygote’’ policies may be trivially defined as lambda expressions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">struct</span> multiplicative_diploid
  {
    <span class="kw">typedef</span> <span class="dt">double</span> result_type;
    <span class="kw">template</span>&lt; <span class="kw">typename</span> iterator_type&gt;
    <span class="kw">inline</span> <span class="dt">double</span> <span class="kw">operator</span>()(<span class="dt">const</span> iterator_type &amp; g1, <span class="dt">const</span> iterator_type &amp; g2,
                             <span class="dt">const</span> <span class="dt">double</span> scaling = <span class="dv">1</span>.) <span class="dt">const</span>
    {
      <span class="kw">using</span> __mtype = <span class="kw">typename</span> iterator_type::value_type::mutation_list_type_iterator;
      <span class="kw">return</span> site_dependent_fitness()(g1,g2,
      <span class="co">//Homozygote policy</span>
                      [&amp;](<span class="dt">double</span> &amp; fitness, <span class="dt">const</span> __mtype  &amp; mut)
                      {
                    fitness *= (<span class="dv">1</span>. + scaling*mut-&gt;s);
                      },
                                      <span class="co">//Heterozygote policy</span>
                      [](<span class="dt">double</span> &amp; fitness,<span class="dt">const</span> __mtype &amp; mut)
                      {
                    fitness *= (<span class="dv">1</span>. + mut-&gt;h*mut-&gt;s);
                      },
                                      <span class="dv">1</span>.);
    }
  };</code></pre>
<p>That last variable, scaling, means that fitness is the product of <span class="math">1, 1 + <em>s</em><em>h</em>, 1 + <em>s</em> × <em>s</em><em>c</em><em>a</em><em>l</em><em>i</em><em>n</em><em>g</em></span> over sites. This allows you to recreate results from the different parts of the literature that use <span class="math"><em>s</em><em>c</em><em>a</em><em>l</em><em>i</em><em>n</em><em>g</em> = 1</span> and 2. Many classic results are based on a scaling of 2.</p>
<p>To use the multiplicative fitness policy in your simulations, this goes to <strong>KTfwd::sample_diploid</strong>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  std::bind(multiplicative_diploid(),std::placeholders::_1,std::placeholders::_2,<span class="dv">2</span>.)</code></pre>
<p>If you wish to create your own site-dependent fitness policies, the recipe is:</p>
<ol style="list-style-type: decimal">
<li>Create your own versions of the policies determining what happens in diploids homozygous vs. heterozygous for a mutation. <strong>These policies are passed the current fitness from the algorithm and an iterator to a mutation object.</strong></li>
<li>Write a wrapper function like multiplicative_diploid that passes these policies to <strong>{KTfwd::site_dependent_fitness</strong>, <em>which itself is a policy requiring that iterators to two gametes, the homozygote/heterozygote policies, and a starting value for fitness be passed to it.</em> In the example of the built-in multiplicative fitness policy, that value of <span class="math">1</span> that is passed as the last argument to <strong>KTfwd::site_dependent_fitness</strong> is the initial value of fitness for a diploid. In other words, <span class="math"><em>w</em> = 1</span> initially, and <span class="math"><em>w</em></span> is then modified by <strong>KTfwd::multiplicative_fitness_updater_het</strong> or <strong>KTfwd::multiplicative_fitness_updater_hom</strong> as appropriate.</li>
<li>This wrapper function is your new fitness policy.</li>
</ol>
<p>Note: the implementation <strong>KTfwd::site_dependent_fitness</strong> is a lot of iterator/pointer arithmetic.</p>
<h2 id="haplotype-based-fitness-policies">Haplotype based fitness policies</h2>
<p>Here is one that assume a user-defined mutation type with effect size <span class="math"><em>e</em></span> associated with it. The effect of a haplotype is additive, the genetic model is recessive, and the phenotype is the genetic effect + a Gaussian random variable with standard deviation sigma. Finally, fitnesses are under Gaussian stabilizing selection with a standard deviation of 1 and mean 0.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> hapfitness
{
  <span class="kw">typedef</span> result_type <span class="dt">double</span>;
  <span class="kw">template</span>&lt;<span class="kw">typename</span> gam_itr
  <span class="dt">double</span> <span class="kw">operator</span>()(<span class="dt">const</span> gam_itr &amp; g1,
                    <span class="dt">const</span> gam_itr &amp; g2,
                    gsl_rng * r,
                    <span class="dt">const</span> <span class="dt">double</span> &amp; sigmaE) <span class="dt">const</span>
   {
     <span class="dt">double</span> sum1=<span class="dv">0</span>.,sum2=<span class="dv">0</span>.;
     <span class="kw">typedef</span> <span class="kw">typename</span> gam_itr::value_type::mutation_container::const_iterator mci;
     <span class="kw">for</span>( mci mitr = g1.smutations.begin() ; mitr != g1.smutations.end() ; ++mitr )
     {
       <span class="co">//mitr is an iterator to an iterator!</span>
       sum1 += (*mitr)-&gt;e;
     }
     <span class="kw">for</span>( mci mitr = g2.smutations.begin() ; mitr != g2.smutations.end() ; ++mitr )
     {
       <span class="co">//mitr is an iterator to an iterator!</span>
       sum2 += (*mitr)-&gt;e;
     }

     <span class="co">//make sum1 be the value closest to 0</span>
     <span class="kw">if</span>( fabs(sum1) &gt; fabs(sum2) ) { std::swap(sum1,sum2); }

     <span class="co">//add noise to fitness</span>
     <span class="co">//Using sum1 as the genetic part makes the model recessive</span>
     <span class="dt">double</span> pheno = sum1 + gsl_ran_gaussian(r,sigmaE);
     
     <span class="co">/*</span>
<span class="co">       Return fitnees under Gaussian stabilizing model.</span>
<span class="co">       This is the only part of the Gaussian pdf that</span>
<span class="co">       matters.  The rest is a constant</span>
<span class="co">       and so won&#39;t affect sampling prop to fitness.</span>
<span class="co">      */</span>
     <span class="kw">return</span> std::exp( -std::pow(pheno,<span class="dv">2</span>) /<span class="dv">2</span>. );
   }
};</code></pre>
<p>To use the above policy:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    std::bind( hapfitness(),
        std::placeholders::_1,std::placeholders::_2,
    r,sigmaE );</code></pre>
<p>Please note that a long-running annoyance with open-source C++ compilers (GCC!) is whether or not exp, pow, log, etc., are in namespace std or in the global namespace. This can vary from version to version and across operating systems. Sometimes, you need to say <strong>std::exp</strong> when on another system that fails and you need <strong>::exp</strong>.</p>
<h2 id="updating-and-removal-policies">Updating and removal policies</h2>
<p>During the course of a simulation, new mutation and gamete types come and go. New types must be entered in to their approproate containers. The relevant policies are basically searches followed by either a member variable update or an insertion. For example, consider our mutation model policy in section . The mutation returned from that function is not currently found in our mutation list (because it has a unique position). Therefore, the relevant policy is just to insert the new mutation at the end of the doubly-linked list of mutations. Likewise, a gamete with a new mutation from that model cannot be identical to any currently-segregating gamete. Therefore, a good policy is just to insert it at the end of the doubly-linked list of gametes (or push it back to the vector of gametes in a gamete-based simulation). However, a recombination event could make either a new gamete or a pre-existing gamete. Thus, a policy to insert a recombinant gamete should do the following:</p>
<ol style="list-style-type: decimal">
<li>Figure out of the gamete is new or not.</li>
<li>If it is new, add it to the end of the gamete container.</li>
<li>It it is not new, do something intelligent, such as return the iterator to the pre-existing version of that gamete in the container.</li>
</ol>
<p>These types of policies are simple. See the header files <strong>fwdpp/insertion_policies.hpp</strong> and <strong>fwdpp/fwd_functional.hpp</strong>. The latter contains the functions passed to <strong>KTfwd::remove_lost</strong> and <strong>KTfwd::remove_fixed_lost</strong>–see the example programs (and the next section here) for concrete examples.</p>
<h1 id="putting-it-all-togeter-kinda">Putting it all togeter (kinda)</h1>
<p>Ok, once we have defined our mutation types, our containers, and our policies, a single generation of a constant-sized population in an individual-based simulation is evolved a follows:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">using</span> std::placeholders; <span class="co">//_1,_2, etc.</span>
  <span class="dt">double</span> wbar = KTfwd::sample_diploid(r,
                                      &amp;gametes,  <span class="co">//non-const pointer to gametes</span>
                                      &amp;diploids, <span class="co">//non-const pointer to diploids</span>
                                      &amp;mutations, <span class="co">//non-const pointer to mutations</span>
                                      N,     <span class="co">//current pop size, remains constant</span>
                                      mu,    <span class="co">//mutation rate per gamete</span>
                                      <span class="co">/*</span>
<span class="co">                                      The mutation model (defined above) will pass each gamete</span>
<span class="co">                         to be mutated to the mutation model function.  Again, _1</span>
<span class="co">                         is used as a placeholder for that gamete.</span>
<span class="co">                           */</span>
                           std::bind(mutmodel_Qtrait,r,_1,mu_neutral,mu_selected,sigma_e,&amp;lookup),
                       <span class="co">//The recombination policy includes the recombination map policy</span>
                           std::bind(KTfwd::genetics101(),_1,_2,
                           &amp;gametes,
                               littler,
                               r,
                               recmap),
                       <span class="co">/*</span>
<span class="co">                     Policy to insert new mutations at the end of the mutations list</span>
<span class="co">                       */</span>
                           std::bind(KTfwd::insert_at_end&lt;mtype,mlist&gt;,_1,_2),
                       <span class="co">/*</span>
<span class="co">                     Policy telling KTfwd::mutate how to add mutated gametes into the gamete pool.</span>
<span class="co">                     If mutation results in a new gamete, add that gamete to the </span>
<span class="co">                     end of gametes. This is always the case under infinitely-many sites,</span>
<span class="co">                     but for other mutation models, mutation may result in a new</span>
<span class="co">                     copy identical to an existing gamete.  If so,</span>
<span class="co">                     that gamete&#39;s frequency increases by 1.</span>
<span class="co">                       */</span>
                           std::bind(KTfwd::insert_at_end&lt;gtype,glist&gt;,_1,_2),
                           std::bind(  std::bind( hapfitness(),
                                                   _1,_2,
                                                   r,sigmaE ),
                           <span class="co">/*</span>
<span class="co">                                         Only remove lost mutations</span>
<span class="co">                           */</span>
                           std::bind(KTfwd::mutation_remover(),_1,<span class="dv">0</span>));
          <span class="co">//Clean up the mutations list.  This also resets ``checked&#39;&#39; in each mutation to zero,</span>
          <span class="co">//which is that ``internal detail&#39;&#39; referred to above</span>
          <span class="co">//We don&#39;t removed fixed mutations b/c this is a quantitative trait simulation</span>
          KTfwd::remove_lost(&amp;mutations,&amp;lookup,generation);</code></pre>
</body>
</html>
